{"version":3,"sources":["logo.svg","components/canvas.js","App.js","reportWebVitals.js","index.js"],"names":["counter","linecounter","newRectangle","pos","id","x","y","width","height","stageRef","React","createRef","MainCanvas","state","isBipartite","canvas","lines","adjList","edgenodestart","handleClick","e","target","getStage","getPointerPosition","setState","prevState","handleDragStart","to","shadowOffsetX","shadowOffsetY","shadowBlur","shadowColor","scaleX","scaleY","handleDragEnd","duration","easing","Konva","Easings","ElasticEaseOut","addEdge","attrs","flag","nodestart","nodestartx","nodestarty","nodeend","nodeendx","nodeendy","current","find","numlines","i","length","startid","endid","angle","radius","dx","dy","Math","atan2","cos","PI","sin","isgrouped","newline","points","groupnumber","genAdjlist","updateLine","nodeid","layer","findOne","curpoints","isundirected","startend","sort","newDict","myDict","colors","adjDict","queue","push","curnode","shift","adjNode","render","window","innerWidth","innerHeight","onClick","ref","map","key","stroke","strokeWidth","toString","draggable","fill","onDragStart","onDragMove","onDragEnd","Component","App","className","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.5d03cc0b.chunk.js","sourcesContent":["export default __webpack_public_path__ + \"static/media/logo.6ce24c58.svg\";","import React, { Component } from \"react\";\r\nimport Konva from \"konva\";\r\nimport { Stage, Layer, Rect, Circle, Line } from \"react-konva\";\r\n\r\n// creates a random number between 1 and a number parameter passed in as \"num\"\r\nconst random = num => Math.floor(Math.random() * num) + 1;\r\nvar counter = 1;\r\nvar linecounter = 1;\r\n// creates a new object with random: x, y, width, and height values (the number passed in represents a maximum value)\r\nconst newRectangle = (pos) => (\r\n    {\r\n        id: counter,\r\n        x: pos.x,\r\n        y: pos.y,\r\n        width: 40,\r\n        height: 40\r\n    });\r\nconst stageRef = React.createRef();\r\nexport default class MainCanvas extends Component {\r\n\r\n\r\n    state = {\r\n        isBipartite: true,\r\n        canvas: [],\r\n        lines: [],\r\n        adjList: {},\r\n        edgenodestart: [null, null, null]\r\n    };\r\n\r\n    handleClick = (e) => {\r\n\r\n        const emptySpace = e.target === e.target.getStage();\r\n        if (!emptySpace) {\r\n            return;\r\n        }\r\n        const pos = e.target.getStage().getPointerPosition();\r\n        this.setState(prevState => ({\r\n            canvas: [...prevState.canvas, { ...newRectangle(pos) }],\r\n\r\n        }));\r\n        counter += 1;\r\n    };\r\n\r\n    handleDragStart = e => {\r\n        e.target.to({\r\n            shadowOffsetX: 0,\r\n            shadowOffsetY: 0,\r\n            shadowBlur: 10,\r\n            shadowColor: \"black\",\r\n            scaleX: 1.15,\r\n            scaleY: 1.15\r\n        });\r\n    };\r\n\r\n    handleDragEnd = e => {\r\n        e.target.to({\r\n            duration: 0.5,\r\n            easing: Konva.Easings.ElasticEaseOut,\r\n            scaleX: 1,\r\n            scaleY: 1,\r\n            shadowBlur: 0,\r\n        });\r\n    };\r\n    addEdge = (e) => {\r\n\r\n        //console.log(this.state.adjlist);\r\n        if (this.state.edgenodestart[0] == null) {\r\n            this.setState({\r\n                edgenodestart: [e.target.attrs.id, e.target.attrs.x, e.target.attrs.y]\r\n            })\r\n\r\n        } else {\r\n            var flag = 0;\r\n            var nodestart = this.state.edgenodestart[0];\r\n            var nodestartx = this.state.edgenodestart[1];\r\n            var nodestarty = this.state.edgenodestart[2];\r\n            var nodeend = e.target.attrs.id;\r\n            var nodeendx = e.target.attrs.x;\r\n            var nodeendy = e.target.attrs.y;\r\n            var layer = stageRef.current;\r\n            var lines = layer.find('#line');\r\n            var numlines = 0;\r\n            var i = 0\r\n            var lastindex = 0;\r\n            for (i = 0; i < lines.length; i += 1) {\r\n                if ((lines[i].attrs.startid === nodestart && lines[i].attrs.endid === nodeend) || (lines[i].attrs.startid === nodeend && lines[i].attrs.endid === nodestart)) {\r\n\r\n                    flag = 1;\r\n                    numlines += 1;\r\n                    lastindex = i;\r\n\r\n                }\r\n            }\r\n            //console.log(numlines);\r\n            const radius = 20;\r\n            let angle = 0;\r\n            var flag = 0;\r\n            if (nodestartx >= nodeendx) {\r\n                flag = 1;\r\n            }\r\n            const dx = nodestartx - nodeendx;\r\n            const dy = nodestarty - nodeendy;\r\n            angle = Math.atan2(-dy, dx);\r\n            if (numlines === 1) {\r\n                if (flag != 1) {\r\n                    nodestartx = nodestartx + -radius * (Math.cos(angle + Math.PI - 1) * .5);\r\n                    nodestarty = nodestarty + radius * (Math.sin(angle + Math.PI - 1) * .5);\r\n                    nodeendx = nodeendx + -radius * (Math.cos(angle + 1) * .5);\r\n                    nodeendy = nodeendy + radius * (Math.sin(angle + 1) * .5);\r\n                } else {\r\n                    nodestartx = nodestartx + -radius * (Math.cos(angle + Math.PI + 1) * .5);\r\n                    nodestarty = nodestarty + radius * (Math.sin(angle + Math.PI + 1) * .5);\r\n                    nodeendx = nodeendx + -radius * (Math.cos(angle - 1) * .5);\r\n                    nodeendy = nodeendy + radius * (Math.sin(angle - 1) * .5);\r\n                }\r\n            }\r\n            else if (numlines === 2) {\r\n\r\n                if (flag != 1) {\r\n                    nodestartx = nodestartx + -radius * (Math.cos(angle + Math.PI + 1) * .5);\r\n                    nodestarty = nodestarty + radius * (Math.sin(angle + Math.PI + 1) * .5);\r\n                    nodeendx = nodeendx + -radius * (Math.cos(angle - 1) * .5);\r\n                    nodeendy = nodeendy + radius * (Math.sin(angle - 1) * .5);\r\n                } else {\r\n                    nodestartx = nodestartx + -radius * (Math.cos(angle + Math.PI - 1) * .5);\r\n                    nodestarty = nodestarty + radius * (Math.sin(angle + Math.PI - 1) * .5);\r\n                    nodeendx = nodeendx + -radius * (Math.cos(angle + 1) * .5);\r\n                    nodeendy = nodeendy + radius * (Math.sin(angle + 1) * .5);\r\n                };\r\n            }\r\n\r\n            var isgrouped = false;\r\n            var groupnumber = numlines + 1;\r\n            if (numlines > 0) {\r\n                isgrouped = true;\r\n            }\r\n            var newline = {\r\n                id: linecounter,\r\n                startid: nodestart,\r\n                endid: nodeend,\r\n                points: [nodestartx, nodestarty, nodeendx, nodeendy],\r\n                isgrouped: isgrouped,\r\n                groupnumber: groupnumber\r\n            }\r\n            this.setState(prevState => ({\r\n                lines: [...prevState.lines, { ...newline }]\r\n            }));\r\n            this.setState({\r\n                edgenodestart: [null, null, null]\r\n            })\r\n            linecounter += 1;\r\n            this.genAdjlist(linecounter, true);//currently undirected graph\r\n\r\n        }\r\n\r\n    }\r\n    updateLine = (e) => {\r\n        var nodeid = e.target.attrs.id;\r\n        var layer = stageRef.current;\r\n        var lines = layer.find('#line');\r\n\r\n        for (var i = 0; i < lines.length; i += 1) {\r\n            if (lines[i].attrs.startid === nodeid) {\r\n                var nodestart = layer.findOne('#' + lines[i].attrs.startid);\r\n                var nodeend = layer.findOne('#' + lines[i].attrs.endid);\r\n                var flag = 0;\r\n                var nodestartx = nodestart.attrs.x;\r\n                var nodestarty = nodestart.attrs.y;\r\n                var nodeendx = nodeend.attrs.x;\r\n                var nodeendy = nodeend.attrs.y;\r\n                if (nodestartx >= nodeendx) {\r\n                    flag = 1;\r\n                }\r\n                const radius = 20;\r\n                const dx = nodestartx - nodeendx;\r\n                const dy = nodestarty - nodeendy;\r\n                let angle = Math.atan2(-dy, dx);\r\n                if (lines[i].attrs.groupnumber % 3 === 1 || lines[i].attrs.isgrouped === false) {\r\n                    var curpoints = lines[i].attrs.points\r\n                    curpoints[0] = e.target.attrs.x;\r\n                    curpoints[1] = e.target.attrs.y;\r\n                    lines[i].attrs.points = curpoints;\r\n                }\r\n                else if (lines[i].attrs.groupnumber % 3 === 2) {\r\n                    if (flag != 1) {\r\n                        nodestartx = nodestartx + -radius * (Math.cos(angle + Math.PI - 1) * .5);\r\n                        nodestarty = nodestarty + radius * (Math.sin(angle + Math.PI - 1) * .5);\r\n                        nodeendx = nodeendx + -radius * (Math.cos(angle + 1) * .5);\r\n                        nodeendy = nodeendy + radius * (Math.sin(angle + 1) * .5);\r\n                    } else {\r\n                        nodestartx = nodestartx + -radius * (Math.cos(angle + Math.PI + 1) * .5);\r\n                        nodestarty = nodestarty + radius * (Math.sin(angle + Math.PI + 1) * .5);\r\n                        nodeendx = nodeendx + -radius * (Math.cos(angle - 1) * .5);\r\n                        nodeendy = nodeendy + radius * (Math.sin(angle - 1) * .5);\r\n                    }\r\n\r\n                    var curpoints = lines[i].attrs.points\r\n                    curpoints[0] = nodestartx;\r\n                    curpoints[1] = nodestarty;\r\n                    curpoints[2] = nodeendx;\r\n                    curpoints[3] = nodeendy;\r\n                    lines[i].attrs.points = curpoints;\r\n                }\r\n                else if (lines[i].attrs.groupnumber % 3 === 0) {\r\n                    if (flag != 1) {\r\n                        nodestartx = nodestartx + -radius * (Math.cos(angle + Math.PI + 1) * .5);\r\n                        nodestarty = nodestarty + radius * (Math.sin(angle + Math.PI + 1) * .5);\r\n                        nodeendx = nodeendx + -radius * (Math.cos(angle - 1) * .5);\r\n                        nodeendy = nodeendy + radius * (Math.sin(angle - 1) * .5);\r\n                    } else {\r\n                        nodestartx = nodestartx + -radius * (Math.cos(angle + Math.PI - 1) * .5);\r\n                        nodestarty = nodestarty + radius * (Math.sin(angle + Math.PI - 1) * .5);\r\n                        nodeendx = nodeendx + -radius * (Math.cos(angle + 1) * .5);\r\n                        nodeendy = nodeendy + radius * (Math.sin(angle + 1) * .5);\r\n                    }\r\n\r\n                    var curpoints = lines[i].attrs.points\r\n                    curpoints[0] = nodestartx;\r\n                    curpoints[1] = nodestarty;\r\n                    curpoints[2] = nodeendx;\r\n                    curpoints[3] = nodeendy;\r\n                    lines[i].attrs.points = curpoints;\r\n                }\r\n            }\r\n            if (lines[i].attrs.endid === nodeid) {\r\n                var nodestart = layer.findOne('#' + lines[i].attrs.startid);\r\n                var nodeend = layer.findOne('#' + lines[i].attrs.endid);\r\n                var nodestartx = nodestart.attrs.x;\r\n                var nodestarty = nodestart.attrs.y;\r\n                var nodeendx = nodeend.attrs.x;\r\n                var nodeendy = nodeend.attrs.y;\r\n                const radius = 20;\r\n                var flag = 0;\r\n                var nodestartx = nodestart.attrs.x;\r\n                var nodestarty = nodestart.attrs.y;\r\n                var nodeendx = nodeend.attrs.x;\r\n                var nodeendy = nodeend.attrs.y;\r\n                if (nodestartx >= nodeendx) {\r\n                    flag = 1;\r\n                }\r\n                const dx = nodestartx - nodeendx;\r\n                const dy = nodestarty - nodeendy;\r\n                let angle = Math.atan2(-dy, dx);\r\n\r\n                if (lines[i].attrs.groupnumber % 3 === 1 || lines[i].attrs.isgrouped === false) {\r\n                    var curpoints = lines[i].attrs.points\r\n                    curpoints[2] = e.target.attrs.x;\r\n                    curpoints[3] = e.target.attrs.y;\r\n                    lines[i].attrs.points = curpoints;\r\n                }\r\n                else if (lines[i].attrs.groupnumber % 3 === 2) {\r\n                    if (flag != 1) {\r\n                        nodestartx = nodestartx + -radius * (Math.cos(angle + Math.PI - 1) * .5);\r\n                        nodestarty = nodestarty + radius * (Math.sin(angle + Math.PI - 1) * .5);\r\n                        nodeendx = nodeendx + -radius * (Math.cos(angle + 1) * .5);\r\n                        nodeendy = nodeendy + radius * (Math.sin(angle + 1) * .5);\r\n                    } else {\r\n                        nodestartx = nodestartx + -radius * (Math.cos(angle + Math.PI + 1) * .5);\r\n                        nodestarty = nodestarty + radius * (Math.sin(angle + Math.PI + 1) * .5);\r\n                        nodeendx = nodeendx + -radius * (Math.cos(angle - 1) * .5);\r\n                        nodeendy = nodeendy + radius * (Math.sin(angle - 1) * .5);\r\n                    }\r\n                    var curpoints = lines[i].attrs.points\r\n                    curpoints[0] = nodestartx;\r\n                    curpoints[1] = nodestarty;\r\n                    curpoints[2] = nodeendx;\r\n                    curpoints[3] = nodeendy;\r\n                    lines[i].attrs.points = curpoints;\r\n                }\r\n                else if (lines[i].attrs.groupnumber % 3 === 0) {\r\n                    if (flag != 1) {\r\n                        nodestartx = nodestartx + -radius * (Math.cos(angle + Math.PI + 1) * .5);\r\n                        nodestarty = nodestarty + radius * (Math.sin(angle + Math.PI + 1) * .5);\r\n                        nodeendx = nodeendx + -radius * (Math.cos(angle - 1) * .5);\r\n                        nodeendy = nodeendy + radius * (Math.sin(angle - 1) * .5);\r\n                    } else {\r\n                        nodestartx = nodestartx + -radius * (Math.cos(angle + Math.PI - 1) * .5);\r\n                        nodestarty = nodestarty + radius * (Math.sin(angle + Math.PI - 1) * .5);\r\n                        nodeendx = nodeendx + -radius * (Math.cos(angle + 1) * .5);\r\n                        nodeendy = nodeendy + radius * (Math.sin(angle + 1) * .5);\r\n                    }\r\n\r\n                    var curpoints = lines[i].attrs.points\r\n                    curpoints[0] = nodestartx;\r\n                    curpoints[1] = nodestarty;\r\n                    curpoints[2] = nodeendx;\r\n                    curpoints[3] = nodeendy;\r\n                    lines[i].attrs.points = curpoints;\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n    genAdjlist = (newline, isundirected) => {\r\n        var layer = stageRef.current;\r\n        var lines = layer.find('#line');\r\n        var adjList = {};\r\n        var flag = false;\r\n        for (var i = 0; i < lines.length; i += 1) {\r\n            if (isundirected === true) {\r\n                // for undirected parallel edges will never add a new edge, makes sure that if we have 5,4 we know 5 is adjacent from 4\r\n                var startend = [lines[i].attrs.startid, lines[i].attrs.endid].sort();\r\n            } else {\r\n                var startend = [lines[i].attrs.startid, lines[i].attrs.endid];\r\n            }\r\n\r\n            if (adjList[startend[0]] != null) {\r\n                var newDict = adjList[startend[0]];\r\n                if (newDict[startend[1]] != null) {\r\n                    newDict[startend[1]] += 1;\r\n                } else {\r\n                    newDict[startend[1]] = 1;\r\n                    adjList[startend[0]] = newDict;\r\n                }\r\n\r\n            } else {\r\n                var myDict = {}\r\n                myDict[startend[1]] = 1;\r\n                adjList[startend[0]] = myDict;\r\n            }\r\n        }\r\n        //console.log(adjList);\r\n        this.setState({ adjList: adjList }, () =>\r\n            this.isBipartite()\r\n        );\r\n    }\r\n    isBipartite = () => {\r\n\r\n        var isBipartite = true;\r\n        if (this.state.lines.length === 0) {\r\n            //console.log(this.state.isBipartite);\r\n        } else {\r\n            let colors = {}; // will store the color of each node with false and 2 true\r\n            for (const adjDict in this.state.adjList) {\r\n                if (adjDict in colors === false) {// only do bfs on nodes that werent visited\r\n                    var queue = [] // queue for breadth first search\r\n                    queue.push([adjDict, false]);\r\n                    colors[adjDict] = false;\r\n                    while (queue.length > 0) {\r\n                        var curnode = queue.shift();// pop first node by shifting array\r\n                        for (const adjNode in this.state.adjList[curnode[0]]) {\r\n                            if (adjNode in colors === true && colors[adjNode] === curnode[1]) {\r\n                                isBipartite = false;\r\n                                break;\r\n                            }\r\n\r\n                            colors[adjNode] = !curnode[1];\r\n                            queue.push([adjNode, !curnode[1]]);\r\n                        }\r\n                        for (const adjDict in this.state.adjList) { // get any other nodes since undirected\r\n                            if (curnode[0] in this.state.adjList[adjDict] === true && adjDict in colors != true) {\r\n                                colors[adjDict] = !curnode[1];\r\n                                queue.push([adjDict, !curnode[1]]);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this.setState({\r\n            isBipartite: isBipartite\r\n        });\r\n\r\n    }\r\n\r\n    render = () => (\r\n        <div >\r\n            {\r\n                this.state.isBipartite ?\r\n                    <p>Bipartite: True</p>\r\n                    :\r\n                    <p>Bipartite: False</p>\r\n            }\r\n\r\n            <Stage width={window.innerWidth} height={window.innerHeight} onClick={this.handleClick} ref={stageRef}  >\r\n\r\n                <Layer>\r\n\r\n                    {this.state.lines.map(({ points, startid, endid, isgrouped, groupnumber }, key) => ( // like a \"for loop\", this maps over this.state.canvas objects and pulls out the height, width, x, y properties to be used below\r\n                        <Line\r\n                            id=\"line\"\r\n                            key={key}\r\n                            startid={startid}\r\n                            endid={endid}\r\n                            points={points}\r\n                            stroke='black'\r\n                            strokeWidth={3}\r\n                            isgrouped={isgrouped}\r\n                            groupnumber={groupnumber}\r\n                        />\r\n                    ))}\r\n\r\n                    {this.state.canvas.map(({ height, width, x, y, id }, key) => (\r\n                        // loop edges will be circles rotated around offset\r\n                        <Circle\r\n                            id={id.toString()}\r\n                            key={key}\r\n                            x={x}\r\n                            y={y}\r\n                            width={width}\r\n                            height={height}\r\n                            stroke=\"black\"\r\n                            strokeWidth={3}\r\n                            draggable='true'\r\n                            fill=\"white\"\r\n\r\n                            onDragStart={this.handleDragStart}\r\n                            onDragMove={this.updateLine}\r\n                            onDragEnd={this.handleDragEnd}\r\n                            onClick={this.addEdge}\r\n                        />\r\n                    ))}\r\n\r\n                </Layer>\r\n            </Stage>\r\n        </div>\r\n\r\n    );\r\n}","import logo from './logo.svg';\nimport './App.css';\nimport MainCanvas from './components/canvas.js'\nimport { Stage, Layer, Rect, Text } from 'react-konva';\nimport Konva from 'konva';\nfunction App() {\n  \n  return (\n    <div className=\"App\">\n      <MainCanvas></MainCanvas>\n      \n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}