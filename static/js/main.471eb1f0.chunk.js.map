{"version":3,"sources":["logo.svg","components/canvas.js","App.js","reportWebVitals.js","index.js"],"names":["counter","linecounter","loopcounter","minHeap","Heap","stageRef","React","createRef","MainCanvas","state","isBipartite","delete","color","numComponents","undirected","canvas","lines","loops","bridgeDict","showBridges","adjList","edgenodestart","generateNode","pos","newNode","length","id","pop","x","y","width","height","fill","handleClick","e","target","getStage","getPointerPosition","newnode","setState","prevState","genAdjlist","handleDragStart","moveToTop","to","scaleX","scaleY","handleDragEnd","newnodes","nodeid","attrs","i","parseInt","newloops","duration","easing","Konva","Easings","ElasticEaseOut","addEdge","layer","current","nodedeleteid","nodedelete","findOne","find","linedeleteids","startid","endid","newlines","splice","push","undefined","label","newLoop","newloop","concat","flag","nodestart","nodestartx","nodestarty","nodeend","nodeendx","nodeendy","numlines","angle","radius","dx","dy","Math","atan2","cos","PI","sin","isgrouped","newline","points","groupnumber","updateLine","curpoints","editnode","loop","position","returnundirected","selfid","startend","findBridges","visited","queue","adjDict","curnode","shift","topologicalSort","processed","visiting","stack","node","dfs","reverse","cyclecheck","output","colors","initTime","lowestAncestor","parent","timer","child","min","j","deleteLine","deleteLoop","changeUndirected","val","createntries","JSXadjList","className","style","margin","minWidth","neighborlist","toString","letterSpacing","key","keyrev","topologicalordering","this","slice","usefultext","display","flexDirection","boxShadow","justifyContent","marginRight","type","readOnly","checked","onClick","backgroundColor","padding","textAlign","listStyleType","window","innerWidth","innerHeight","ref","left","map","radiusX","radiusY","stroke","strokeWidth","name","pointerWidth","draggable","onDragStart","onDragMove","onDragEnd","fontFamily","fontStyle","fontSize","text","listening","shadowBlur","shadowOpacity","shadowOffsetX","shadowOffsetY","cornerRadius","align","lineHeight","Component","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.471eb1f0.chunk.js","sourcesContent":["export default __webpack_public_path__ + \"static/media/logo.6ce24c58.svg\";","import React, { Component } from \"react\";\nimport Konva from \"konva\";\nimport { Stage, Layer, Ellipse, Circle, Line, Arrow, Text, Rect, Group } from \"react-konva\";\nimport Heap from 'heap-js';\n\nvar counter = 1;\nvar linecounter = 1;\nvar loopcounter = 1;\nconst minHeap = new Heap();\nconst stageRef = React.createRef();\n\nexport default class MainCanvas extends Component {\n    state = {\n        isBipartite: true,\n        delete: false,\n        color: false,\n        numComponents: 0,\n        undirected: true,\n        canvas: [],\n        lines: [],\n        loops: [],\n        bridgeDict: {},\n        showBridges: false,\n        adjList: {},\n        edgenodestart: [null, null, null],\n    };\n\n    generateNode = (pos) => {\n        var newNode = {};\n        if (minHeap.length > 0) {\n            var newid = minHeap.pop();\n            newNode = {\n                id: newid,\n                x: pos.x,\n                y: pos.y,\n                width: 40,\n                height: 40,\n                fill: \"white\"\n            }\n            counter -= 1;\n        } else {\n            newNode = {\n                id: counter,\n                x: pos.x,\n                y: pos.y,\n                width: 40,\n                height: 40,\n                fill: \"white\"\n            }\n        }\n        return newNode;\n    }\n\n    handleClick = (e) => {\n        if (this.state.delete != true) {\n            const emptySpace = e.target === e.target.getStage();\n            if (!emptySpace) {\n                return;\n            }\n            const pos = e.target.getStage().getPointerPosition();\n            var newnode = this.generateNode(pos);\n            counter += 1\n            this.setState(prevState => ({\n                canvas: [...prevState.canvas, { ...newnode }],\n                edgenodestart: [null, null, null]\n\n            }), () => this.genAdjlist());\n        }\n    };\n\n    handleDragStart = e => {\n        e.target.moveToTop();\n        e.target.to({\n            scaleX: 1.15,\n            scaleY: 1.15,\n        });\n    };\n\n    handleDragEnd = e => {\n        var newnodes = [...this.state.canvas];\n        var nodeid = e.target.attrs.id;\n        for (var i = 0; i < newnodes.length; i += 1) {\n            if (newnodes[i].id === parseInt(nodeid)) {\n                newnodes[i].x = e.target.attrs.x;\n                newnodes[i].y = e.target.attrs.y;\n                break;\n            }\n        }\n        var newloops = [...this.state.loops];\n        for (var i = 0; i < newloops.length; i += 1) {\n            if (newloops[i].nodeid === nodeid) {\n                newloops[i].x = e.target.attrs.x;\n                newloops[i].y = e.target.attrs.y - 40;\n                break;\n            }\n        }\n        this.setState({\n            loops: newloops,\n            canvas: newnodes\n        })\n        e.target.to({\n            duration: 0.5,\n            easing: Konva.Easings.ElasticEaseOut,\n            scaleX: 1,\n            scaleY: 1,\n        });\n    };\n    addEdge = (e) => {\n        if (this.state.color === true && this.state.delete == false) {\n            var newnodes = [...this.state.canvas];\n            for (var i = 0; i < newnodes.length; i += 1) {\n                if ((newnodes[i].id) === parseInt(e.target.attrs.id)) {\n                    if (newnodes[i].fill === \"white\") {\n                        newnodes[i].fill = \"#007bff\"\n                    }\n                    else if (newnodes[i].fill === \"#007bff\") {\n                        newnodes[i].fill = \"#ff5353\"\n                    }\n                    else {\n                        newnodes[i].fill = \"white\"\n                    }\n                    break;\n                }\n            }\n            this.setState({\n                canvas: newnodes,\n                edgenodestart: [null, null, null]\n            })\n            return;\n        }\n        var layer = stageRef.current;\n        if (this.state.delete === true) {\n            var nodedeleteid = e.target.attrs.id;\n            var nodedelete = layer.findOne('#' + e.target.attrs.id);\n            var lines = layer.find('.line');\n            var linedeleteids = {};\n            for (i = 0; i < lines.length; i += 1) {\n                if (lines[i].attrs.startid === nodedelete.attrs.id || lines[i].attrs.endid === nodedelete.attrs.id) {\n                    linedeleteids[lines[i].attrs.id] = true;\n                }\n            }\n            var newlines = [...this.state.lines];\n            for (var i = newlines.length - 1; i > -1; i -= 1) {\n                if ((\"line\" + newlines[i].id) in linedeleteids) {\n                    newlines.splice(i, 1);\n                }\n            }\n            this.setState({\n                lines: newlines\n            })\n            var newnodes = [...this.state.canvas];\n            for (var i = 0; i < newnodes.length; i += 1) {\n                if (parseInt(newnodes[i].id) === parseInt(nodedelete.attrs.id)) {\n                    newnodes.splice(i, 1);\n                    break;\n                }\n            }\n            this.setState({\n                canvas: newnodes\n            })\n            minHeap.push(parseInt(nodedeleteid));\n            var newloops = [...this.state.loops];\n            for (var i = 0; i < newloops.length; i += 1) {\n                if ((newloops[i].nodeid) === nodedeleteid) {\n                    newloops.splice(i, 1);\n                    break;\n                }\n            }\n            this.setState({\n                loops: newloops\n            }, () => this.genAdjlist());\n            this.setState({\n                edgenodestart: [null, null, null]\n            })\n            return;\n        }\n        if (this.state.edgenodestart[0] == null) {\n            this.setState({\n                edgenodestart: [e.target.attrs.id, e.target.attrs.x, e.target.attrs.y]\n            })\n        } else {\n            if (e.target.attrs.id === this.state.edgenodestart[0]) { // create loop\n                var prevloop = layer.findOne('#loop' + e.target.attrs.id); // check if there is already loop\n                if (prevloop === undefined) {\n                    this.setState({\n                        edgenodestart: [null, null, null]\n                    })\n                    var label = layer.findOne('#label' + e.target.attrs.id);\n                    e.target.moveToTop();\n                    label.moveToTop();\n                    var newLoop = {\n                        nodeid: e.target.attrs.id,\n                        id: loopcounter,\n                        x: e.target.attrs.x,\n                        y: e.target.attrs.y - 40,\n                        width: 25,\n                        height: 40\n                    }\n                    loopcounter += 1;\n                    var newloop = this.state.loops.concat(newLoop);\n                    this.setState({ loops: newloop }, () => this.genAdjlist())\n                    this.setState({\n                        edgenodestart: [null, null, null]\n                    })\n                    return\n                }\n                this.setState({\n                    edgenodestart: [null, null, null]\n                })\n                return\n            }\n            var flag = 0;\n            var nodestart = this.state.edgenodestart[0];\n            var nodestartx = this.state.edgenodestart[1];\n            var nodestarty = this.state.edgenodestart[2];\n            var nodeend = e.target.attrs.id;\n            var nodeendx = e.target.attrs.x;\n            var nodeendy = e.target.attrs.y;\n            var lines = layer.find('.line');\n            var numlines = 0;\n            var i = 0\n            for (i = 0; i < lines.length; i += 1) {\n                if ((lines[i].attrs.startid === nodestart && lines[i].attrs.endid === nodeend) || (lines[i].attrs.startid === nodeend && lines[i].attrs.endid === nodestart)) {\n\n                    flag = 1;\n                    numlines += 1;\n                }\n            }\n            const radius = -50;\n            let angle = 0;\n            var flag = 0;\n            if (nodestartx >= nodeendx) {\n                flag = 1;\n            }\n            const dx = nodestartx - nodeendx;\n            const dy = nodestarty - nodeendy;\n            angle = Math.atan2(-dy, dx);\n            if (numlines === 0) {\n                nodestartx = nodestartx + -radius * (Math.cos(angle + Math.PI) * .5);\n                nodestarty = nodestarty + radius * (Math.sin(angle + Math.PI) * .5);\n                nodeendx = nodeendx + -radius * (Math.cos(angle) * .5);\n                nodeendy = nodeendy + radius * (Math.sin(angle) * .5);\n            }\n            else if (numlines === 1) {\n                if (flag != 1) {\n                    nodestartx = nodestartx + -radius * (Math.cos(angle + Math.PI - .5) * .5);\n                    nodestarty = nodestarty + radius * (Math.sin(angle + Math.PI - .5) * .5);\n                    nodeendx = nodeendx + -radius * (Math.cos(angle + .5) * .5);\n                    nodeendy = nodeendy + radius * (Math.sin(angle + .5) * .5);\n                } else {\n                    nodestartx = nodestartx + -radius * (Math.cos(angle + Math.PI + .5) * .5);\n                    nodestarty = nodestarty + radius * (Math.sin(angle + Math.PI + .5) * .5);\n                    nodeendx = nodeendx + -radius * (Math.cos(angle - .5) * .5);\n                    nodeendy = nodeendy + radius * (Math.sin(angle - .5) * .5);\n                }\n            }\n            else if (numlines === 2) {\n\n                if (flag != 1) {\n                    nodestartx = nodestartx + -radius * (Math.cos(angle + Math.PI + .5) * .5);\n                    nodestarty = nodestarty + radius * (Math.sin(angle + Math.PI + .5) * .5);\n                    nodeendx = nodeendx + -radius * (Math.cos(angle - .5) * .5);\n                    nodeendy = nodeendy + radius * (Math.sin(angle - .5) * .5);\n                } else {\n                    nodestartx = nodestartx + -radius * (Math.cos(angle + Math.PI - .5) * .5);\n                    nodestarty = nodestarty + radius * (Math.sin(angle + Math.PI - .5) * .5);\n                    nodeendx = nodeendx + -radius * (Math.cos(angle + .5) * .5);\n                    nodeendy = nodeendy + radius * (Math.sin(angle + .5) * .5);\n                };\n            }\n            else {\n                this.setState({\n                    edgenodestart: [null, null, null]\n                })\n                return;\n            }\n\n            var isgrouped = false;\n            var groupnumber = numlines + 1;\n            if (numlines > 0) {\n                isgrouped = true;\n            }\n            var newline = {\n                id: linecounter,\n                startid: nodestart,\n                endid: nodeend,\n                points: [nodestartx, nodestarty, nodeendx, nodeendy],\n                isgrouped: isgrouped,\n                fill: 'black',\n                groupnumber: groupnumber\n            }\n            this.setState(prevState => ({\n                lines: [...prevState.lines, { ...newline }]\n            }), () => this.genAdjlist());\n            this.setState({\n                edgenodestart: [null, null, null]\n            })\n            linecounter += 1;\n\n        }\n\n    }\n\n    updateLine = (e) => {\n        var nodeid = e.target.attrs.id;\n        var layer = stageRef.current;\n        //UPDATE ALL LINES\n        var lines = layer.find('.line');\n        for (var i = 0; i < lines.length; i += 1) {\n            if (lines[i].attrs.startid === nodeid) {\n                var nodestart = layer.findOne('#' + lines[i].attrs.startid);\n                var nodeend = layer.findOne('#' + lines[i].attrs.endid);\n                var flag = 0;\n                var nodestartx = nodestart.attrs.x;\n                var nodestarty = nodestart.attrs.y;\n                var nodeendx = nodeend.attrs.x;\n                var nodeendy = nodeend.attrs.y;\n                if (nodestartx >= nodeendx) {\n                    flag = 1;\n                }\n                const radius = -50;\n                const dx = nodestartx - nodeendx;\n                const dy = nodestarty - nodeendy;\n                let angle = Math.atan2(-dy, dx);\n                if (lines[i].attrs.groupnumber === 1 || lines[i].attrs.isgrouped === false) {\n                    var curpoints = lines[i].attrs.points\n                    nodestartx = e.target.attrs.x + -radius * (Math.cos(angle + Math.PI) * .5);\n                    nodestarty = e.target.attrs.y + radius * (Math.sin(angle + Math.PI) * .5);\n                    nodeendx = nodeendx + -radius * (Math.cos(angle) * .5);\n                    nodeendy = nodeendy + radius * (Math.sin(angle) * .5);\n                    curpoints[0] = nodestartx;\n                    curpoints[1] = nodestarty;\n                    curpoints[2] = nodeendx;\n                    curpoints[3] = nodeendy;\n                    lines[i].attrs.points = curpoints;\n                }\n                else if (lines[i].attrs.groupnumber === 2) {\n                    if (flag != 1) {\n                        nodestartx = nodestartx + -radius * (Math.cos(angle + Math.PI - .5) * .5);\n                        nodestarty = nodestarty + radius * (Math.sin(angle + Math.PI - .5) * .5);\n                        nodeendx = nodeendx + -radius * (Math.cos(angle + .5) * .5);\n                        nodeendy = nodeendy + radius * (Math.sin(angle + .5) * .5);\n                    } else {\n                        nodestartx = nodestartx + -radius * (Math.cos(angle + Math.PI + .5) * .5);\n                        nodestarty = nodestarty + radius * (Math.sin(angle + Math.PI + .5) * .5);\n                        nodeendx = nodeendx + -radius * (Math.cos(angle - .5) * .5);\n                        nodeendy = nodeendy + radius * (Math.sin(angle - .5) * .5);\n                    }\n\n                    var curpoints = lines[i].attrs.points\n                    curpoints[0] = nodestartx;\n                    curpoints[1] = nodestarty;\n                    curpoints[2] = nodeendx;\n                    curpoints[3] = nodeendy;\n                    lines[i].attrs.points = curpoints;\n                }\n                else if (lines[i].attrs.groupnumber === 3) {\n                    if (flag != 1) {\n                        nodestartx = nodestartx + -radius * (Math.cos(angle + Math.PI + .5) * .5);\n                        nodestarty = nodestarty + radius * (Math.sin(angle + Math.PI + .5) * .5);\n                        nodeendx = nodeendx + -radius * (Math.cos(angle - .5) * .5);\n                        nodeendy = nodeendy + radius * (Math.sin(angle - .5) * .5);\n                    } else {\n                        nodestartx = nodestartx + -radius * (Math.cos(angle + Math.PI - .5) * .5);\n                        nodestarty = nodestarty + radius * (Math.sin(angle + Math.PI - .5) * .5);\n                        nodeendx = nodeendx + -radius * (Math.cos(angle + .5) * .5);\n                        nodeendy = nodeendy + radius * (Math.sin(angle + .5) * .5);\n                    }\n\n                    var curpoints = lines[i].attrs.points\n                    curpoints[0] = nodestartx;\n                    curpoints[1] = nodestarty;\n                    curpoints[2] = nodeendx;\n                    curpoints[3] = nodeendy;\n                    lines[i].attrs.points = curpoints;\n                }\n            }\n            if (lines[i].attrs.endid === nodeid) {\n                var nodestart = layer.findOne('#' + lines[i].attrs.startid);\n                var nodeend = layer.findOne('#' + lines[i].attrs.endid);\n                var nodestartx = nodestart.attrs.x;\n                var nodestarty = nodestart.attrs.y;\n                var nodeendx = nodeend.attrs.x;\n                var nodeendy = nodeend.attrs.y;\n                const radius = -50;\n                var flag = 0;\n                var nodestartx = nodestart.attrs.x;\n                var nodestarty = nodestart.attrs.y;\n                var nodeendx = nodeend.attrs.x;\n                var nodeendy = nodeend.attrs.y;\n                if (nodestartx >= nodeendx) {\n                    flag = 1;\n                }\n                const dx = nodestartx - nodeendx;\n                const dy = nodestarty - nodeendy;\n                let angle = Math.atan2(-dy, dx);\n\n                if (lines[i].attrs.groupnumber === 1 || lines[i].attrs.isgrouped === false) {\n                    var curpoints = lines[i].attrs.points\n                    nodestartx = nodestartx + -radius * (Math.cos(angle + Math.PI) * .5);\n                    nodestarty = nodestarty + radius * (Math.sin(angle + Math.PI) * .5);\n                    nodeendx = nodeendx + -radius * (Math.cos(angle) * .5);\n                    nodeendy = nodeendy + radius * (Math.sin(angle) * .5);\n\n                    curpoints[2] = nodeendx;\n                    curpoints[3] = nodeendy;\n                    curpoints[0] = nodestartx;\n                    curpoints[1] = nodestarty;\n                    lines[i].attrs.points = curpoints;\n                }\n                else if (lines[i].attrs.groupnumber === 2) {\n                    if (flag != 1) {\n                        nodestartx = nodestartx + -radius * (Math.cos(angle + Math.PI - .5) * .5);\n                        nodestarty = nodestarty + radius * (Math.sin(angle + Math.PI - .5) * .5);\n                        nodeendx = nodeendx + -radius * (Math.cos(angle + .5) * .5);\n                        nodeendy = nodeendy + radius * (Math.sin(angle + .5) * .5);\n                    } else {\n                        nodestartx = nodestartx + -radius * (Math.cos(angle + Math.PI + .5) * .5);\n                        nodestarty = nodestarty + radius * (Math.sin(angle + Math.PI + .5) * .5);\n                        nodeendx = nodeendx + -radius * (Math.cos(angle - .5) * .5);\n                        nodeendy = nodeendy + radius * (Math.sin(angle - .5) * .5);\n                    }\n                    var curpoints = lines[i].attrs.points\n                    curpoints[0] = nodestartx;\n                    curpoints[1] = nodestarty;\n                    curpoints[2] = nodeendx;\n                    curpoints[3] = nodeendy;\n                    lines[i].attrs.points = curpoints;\n                }\n                else if (lines[i].attrs.groupnumber === 3) {\n                    if (flag != 1) {\n                        nodestartx = nodestartx + -radius * (Math.cos(angle + Math.PI + .5) * .5);\n                        nodestarty = nodestarty + radius * (Math.sin(angle + Math.PI + .5) * .5);\n                        nodeendx = nodeendx + -radius * (Math.cos(angle - .5) * .5);\n                        nodeendy = nodeendy + radius * (Math.sin(angle - .5) * .5);\n                    } else {\n                        nodestartx = nodestartx + -radius * (Math.cos(angle + Math.PI - .5) * .5);\n                        nodestarty = nodestarty + radius * (Math.sin(angle + Math.PI - .5) * .5);\n                        nodeendx = nodeendx + -radius * (Math.cos(angle + .5) * .5);\n                        nodeendy = nodeendy + radius * (Math.sin(angle + .5) * .5);\n                    }\n\n                    var curpoints = lines[i].attrs.points\n                    curpoints[0] = nodestartx;\n                    curpoints[1] = nodestarty;\n                    curpoints[2] = nodeendx;\n                    curpoints[3] = nodeendy;\n                    lines[i].attrs.points = curpoints;\n                }\n\n            }\n\n        }\n        // update position of loops and labels\n        var editnode = layer.findOne('#' + nodeid);\n        var loop = layer.findOne('#loop' + nodeid);\n        if (loop) {\n            loop.position({ x: editnode.attrs.x, y: editnode.attrs.y - 40 })\n        }\n        var label = layer.findOne('#label' + nodeid);\n        if (label) {\n            label.moveToTop();\n            label.position({ x: nodeid > 9 ? editnode.attrs.x - 9 : editnode.attrs.x - 4, y: editnode.attrs.y - 5 });\n        }\n    }\n\n    genAdjlist = (returnundirected) => {\n        var layer = stageRef.current;\n        var lines = layer.find('.line');\n        var adjList = {};\n        for (var i = 0; i < this.state.canvas.length; i += 1) {\n            adjList[this.state.canvas[i].id] = [];\n        }\n        for (var i = 0; i < this.state.loops.length; i += 1) {\n            var selfid = this.state.loops[i].nodeid;\n            adjList[selfid].push(selfid);\n        }\n        for (var i = 0; i < lines.length; i += 1) {\n            var startend = [lines[i].attrs.startid, lines[i].attrs.endid];\n            adjList[startend[0]].push(parseInt(startend[1]));\n            if (this.state.undirected === true || returnundirected === true) {\n                adjList[startend[1]].push(parseInt(startend[0]));\n            }\n        }\n        if (!returnundirected) {\n            this.setState({ adjList: adjList }, () => {\n                this.isBipartite();\n                this.numComponents();\n                this.findBridges();\n            }\n            );\n        }\n        if (returnundirected === true) {\n            return adjList;\n        }\n    }\n\n    numComponents = () => {\n        var numComponents = 0;\n        var visited = {};\n        var queue = [];\n        for (const adjDict in this.state.adjList) {\n            if (adjDict in visited === false) {\n                numComponents += 1;\n                queue.push(adjDict);\n                visited[adjDict] = true;\n                while (queue.length > 0) {\n                    var curnode = queue.shift();\n                    for (var i = 0; i < this.state.adjList[curnode].length; i += 1) {\n                        if (this.state.adjList[curnode][i] in visited === false) {\n                            queue.push(this.state.adjList[curnode][i]);\n                            visited[this.state.adjList[curnode][i]] = true;\n                        }\n                    }\n                }\n            }\n        }\n        this.setState({\n            numComponents: numComponents\n        })\n    }\n\n    topologicalSort = () => {\n        var processed = {};\n        var visiting = {};\n        var stack = [];\n        for (var node in this.state.adjList) {\n            if (node in processed != true) {\n\n                if (dfs(node, visiting, processed, stack, this.state.adjList)) {\n                    return [];\n                }\n            }\n        }\n        stack.reverse()\n        return stack;\n        function dfs(node, cyclecheck, processed, output, adjList) {\n            if (node in processed) {\n                return false;\n            }\n            if (node in cyclecheck) {\n                return true; // we want to bubble up true in case there is cycle in directed graph.\n            }\n            cyclecheck[node] = true;\n            for (var i = 0; i < adjList[node].length; i += 1) {\n                var foundcycle = dfs(adjList[node][i], cyclecheck, processed, output, adjList);\n                if (foundcycle) {\n                    return true;\n                }\n            }\n            delete cyclecheck[node];\n            processed[node] = true;\n            output.push(\",\");\n            output.push(parseInt(node));\n            return false\n        }\n    }\n\n    isBipartite = () => {\n        var isBipartite = true;\n        if (this.state.lines.length === 0 && this.state.loops.length === 0) {\n            //dont do anything if there arent any edges\n        } else {\n            if (this.state.undirected === false) { // we always want to treat the graph as undirected when checking if it is bipartite\n                var adjList = this.genAdjlist(true);\n            } else {\n                var adjList = this.state.adjList;\n            }\n            let colors = {}; // will store the color of each node with false and true\n            for (var adjDict in this.state.adjList) {\n                if (adjDict in colors === false) {// only do bfs on nodes that werent visited\n                    var queue = [] // queue for breadth first search\n                    queue.push([adjDict, false, -1]);\n                    colors[adjDict] = false; // mark visited\n                    while (queue.length > 0) {\n                        var curnode = queue.shift();// pop first node by shifting array\n                        for (var i = 0; i < adjList[curnode[0]].length; i += 1) {\n                            if (adjList[curnode[0]][i] === curnode[2]) {\n                                // we dont want to go back to the neighbor we previosly visited\n                                continue;\n                            }\n                            if (adjList[curnode[0]][i] in colors === true && colors[adjList[curnode[0]][i]] != curnode[1]) {\n                                // in case we reach node that is visited but is the opposite color then we also know the rest of its neighbors and so on are bipartite\n                                continue;\n                            }\n                            if (adjList[curnode[0]][i] in colors === true && colors[adjList[curnode[0]][i]] === curnode[1]) {\n                                // in case we reach a visited node that wasnt started on and its color is the same as the current color then not bipartite\n                                isBipartite = false;\n                                break;\n                            }\n                            // push neighbor to queue\n                            colors[adjList[curnode[0]][i]] = !curnode[1]; // mark visited\n                            queue.push([adjList[curnode[0]][i], !curnode[1], curnode[0]]);\n                        }\n                    }\n                }\n            }\n        }\n        this.setState({\n            isBipartite: isBipartite\n        });\n    }\n\n    findBridges = () => {\n        var bridgeDict = {};\n        if (this.state.undirected === true && this.state.showBridges === true) {\n            var initTime = {};\n            var lowestAncestor = {};\n            var timer = 1;\n            for (var node in this.state.adjList) {\n                if (node in initTime === false) {\n                    // do dfs if not visited\n                    dfs(parseInt(node), -1, initTime, lowestAncestor, timer, this.state.adjList);\n                }\n            }\n        }\n        this.setState({\n            bridgeDict: bridgeDict\n        }, () => this.showBridges());\n        function dfs(node, parent, initTime, lowestAncestor, timer, adjList) {\n            initTime[node] = timer;\n            lowestAncestor[node] = timer;\n            timer += 1\n            if (adjList[node] != []) {\n                for (var child = 0; child < adjList[node].length; child += 1) {\n                    if (adjList[node][child] === parent) { // dont go back to parent\n                        continue;\n                    }\n                    else if (adjList[node][child] in initTime) {// found visited node so update low of curnode if it is \n                        lowestAncestor[node] = Math.min(initTime[adjList[node][child]], lowestAncestor[node])\n                    } else {// child not visited\n                        dfs(adjList[node][child], node, initTime, lowestAncestor, timer, adjList);\n                        if (lowestAncestor[adjList[node][child]] > initTime[node]) {// if only way to child is from parent then it is bridge\n                            //checks for parallel edges since it wont be a bridge if there is another edge\n                            var counter = 0;\n                            for (var j = 0; j < adjList[node].length; j += 1) {\n                                if (adjList[node][j] === adjList[node][child]) {\n                                    counter += 1;\n                                }\n                            }\n                            if (counter < 2) { // if no other edge going from node to child other than one, then its a bridge.\n                                bridgeDict[[node, adjList[node][child]]] = true;\n                            }\n                        } else { // otherwise update the lowest ancestor reachable from current node ny seeing if the childs lowest acnestor is lower\n                            lowestAncestor[node] = Math.min(lowestAncestor[node], lowestAncestor[adjList[node][child]]);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    deleteLine = (e) => {\n        var newlines = [...this.state.lines];\n        for (var i = 0; i < newlines.length; i += 1) {\n            if (\"line\" + newlines[i].id === e.target.attrs.id) {\n                newlines.splice(i, 1);\n                break;\n            }\n        }\n        this.setState({\n            lines: newlines\n        }, () => this.genAdjlist());\n    }\n\n    deleteLoop = (e) => {\n        var newloops = [...this.state.loops];\n        for (var i = 0; i < newloops.length; i += 1) {\n            if ((\"loop\" + newloops[i].nodeid) === e.target.attrs.id) {\n                newloops.splice(i, 1);\n                break;\n            }\n        }\n        this.setState({\n            loops: newloops\n        }, () => this.genAdjlist())\n    }\n\n    changeUndirected = (val) => {\n        if (val) {\n            this.setState((prevState) => ({ undirected: true }), () => this.genAdjlist());\n        } else {\n            this.setState((prevState) => ({ undirected: false }), () => this.genAdjlist());\n        }\n\n    }\n\n    createntries = () => {\n        var JSXadjList = [];\n        JSXadjList.push(<li className=\"listitems\" key={node} style={{ margin: \"13px\", minWidth: \"110px\" }}>Adjacency List:</li>);\n        for (var node in this.state.adjList) {\n            var neighborlist = [];\n            for (var i = 0; i < this.state.adjList[node].length; i += 1) {\n                neighborlist.push(this.state.adjList[node][i]);\n            }\n            neighborlist = neighborlist.toString();\n            JSXadjList.push(<li className=\"listitems\" key={node} style={{ margin: \"13px\", minWidth: \"110px\", letterSpacing: \"2px\" }}>{node}:{neighborlist}</li>);\n        }\n        return JSXadjList;\n    }\n\n    showBridges = () => {\n        var lines = this.state.lines;\n        for (var i = 0; i < lines.length; i += 1) {\n            if (this.state.undirected === true) {\n                var key = lines[i].startid.toString() + \",\" + lines[i].endid.toString();\n                var keyrev = lines[i].endid.toString() + \",\" + lines[i].startid.toString();\n                if (key in this.state.bridgeDict || keyrev in this.state.bridgeDict) {\n                    lines[i].fill = 'red';\n                } else {\n                    lines[i].fill = 'black';\n                }\n            } else {\n                lines[i].fill = 'black';\n            }\n        }\n        this.setState({\n            lines: lines\n        })\n    }\n\n    render() {\n        var topologicalordering = this.topologicalSort();\n        topologicalordering.slice(-1)\n        if (topologicalordering.length < 1 && this.state.canvas.length > 0) {\n            topologicalordering = \"Cycle Detected!\"\n        }\n        var JSXadjList = this.createntries();\n        var usefultext = (this.state.isBipartite ? \"Bipartite: True\\n\" : \"Bipartite: False\\n\") +\n            (\"Components: \" + (this.state.undirected ? this.state.numComponents : \"N/A\") + \"\\n\") +\n            (\"V: \" + (this.state.canvas.length) + \"\\n\") +\n            (\"E: \" + (this.state.lines.length + this.state.loops.length));\n        return (\n            <div>\n                <div style={{ display: \"flex\", flexDirection: \"row\", boxShadow: \"rgba(0, 0, 0, 0.15) 1.95px 1.95px 2.6px\", justifyContent: \"space-between\" }}>\n                    <h1 className=\"titletext\">Graph Sketcher</h1>\n                    <div style={{ display: \"flex\", flexDirection: \"row\", marginRight: \"5rem\" }}>\n                        {\n                            this.state.undirected === true ?\n                                <p className='checktext'>Show Bridges <input type=\"checkbox\" readOnly={true} className='checkbox' checked={this.state.showBridges === true ? true : false} onClick={() => this.setState((prevState) => ({ showBridges: !prevState.showBridges }), () => this.genAdjlist())}></input></p>\n                                :\n                                null\n                        }\n                        <div style={{ display: \"flex\", flexDirection: \"row\" }}>\n                            <button className=\"optionsbuttons left\" style={this.state.delete === false && this.state.color == false ? { backgroundColor: \"#272942\" } : { backgroundColor: \"#4a508b\" }} onClick={() => this.setState({ delete: false, color: false })}>DRAW</button>\n                            <button className=\"optionsbuttons\" style={this.state.delete === true ? { backgroundColor: \"#272942\" } : { backgroundColor: \"#4a508b\" }} onClick={() => this.setState({ delete: true, color: false })}>DELETE</button>\n                            <button className=\"optionsbuttons right\" style={this.state.delete === false && this.state.color == true ? { backgroundColor: \"#272942\" } : { backgroundColor: \"#4a508b\" }} onClick={() => this.setState({ color: true, delete: false })}>COLOR</button>\n                        </div>\n                        &nbsp;\n                        <div style={{ display: \"flex\", flexDirection: \"row\" }}>\n                            <button className=\"optionsbuttons left\" style={this.state.undirected ? { backgroundColor: \"#272942\" } : { backgroundColor: \"#4a508b\" }} onClick={() => this.changeUndirected(true)}>UNDIRECTED</button>\n                            <button className=\"optionsbuttons right\" style={this.state.undirected ? { backgroundColor: \"#4a508b\" } : { backgroundColor: \"#272942\" }} onClick={() => this.changeUndirected(false)}>DIRECTED</button>\n                        </div>\n                    </div>\n                </div>\n                <div >\n                    <div style={{ display: \"flex\", flexDirection: \"row\" }}>\n                        <div style={{ display: \"flex\", flexDirection: \"row\" }}>\n                            <ul className=\"adjListContainer\" style={{ height: \"100%\", padding: \"0px\", margin: \"0px\", textAlign: \"left\", boxShadow: \"rgba(0, 0, 0, 0.15) 1.95px 1.95px 2.6px\", listStyleType: \"none\" }}>\n                                {JSXadjList}\n                            </ul>\n                            {\n                                this.state.undirected === false ?\n                                    <p className=\"topo\" style={{ boxShadow: \"rgba(0, 0, 0, 0.15) 1.95px 1.95px 2.6px\" }}>Topological Ordering: {topologicalordering}</p>\n                                    :\n                                    null\n                            }\n                        </div>\n                        <Stage width={window.innerWidth - 20} height={window.innerHeight + 400} onClick={this.handleClick} ref={stageRef} style={{ left: 0, position: \"absolute\" }}  >\n                            <Layer>\n                                {this.state.loops.map(({ id, x, y, width, height, nodeid }, key) => ( // like a \"for loop\", this maps over this.state.canvas objects and pulls out the height, width, x, y properties to be used below\n                                    // loop edges will be circles rotated around offset\n                                    <Ellipse\n                                        id={\"loop\" + nodeid}\n                                        nodeid={nodeid}\n                                        key={key}\n                                        x={x}\n                                        y={y}\n                                        radiusX={width}\n                                        radiusY={height}\n                                        stroke='black'\n                                        strokeWidth={3}\n                                        onClick={this.deleteLoop}\n                                    />\n                                ))}\n                                {this.state.lines.map(({ points, startid, endid, isgrouped, groupnumber, id, fill }, key) => ( // like a \"for loop\", this maps over this.state.canvas objects and pulls out the height, width, x, y properties to be used below\n                                    this.state.undirected ?\n                                        <Line\n                                            id={\"line\" + id}\n                                            key={key}\n                                            startid={startid}\n                                            endid={endid}\n                                            points={points}\n                                            stroke={fill}\n                                            strokeWidth={4}\n                                            isgrouped={isgrouped}\n                                            groupnumber={groupnumber}\n                                            name=\"line\"\n                                            onClick={this.deleteLine}\n                                        />\n                                        :\n                                        <Arrow\n                                            id={\"line\" + id}\n                                            key={key}\n                                            startid={startid}\n                                            endid={endid}\n                                            points={points}\n                                            stroke={fill}\n                                            strokeWidth={4}\n                                            isgrouped={isgrouped}\n                                            groupnumber={groupnumber}\n                                            name=\"line\"\n                                            pointerWidth={7}\n                                            fill=\"black\"\n                                            onClick={this.deleteLine}\n                                        />\n                                ))}\n                                {this.state.canvas.map(({ height, width, x, y, id, fill }, key) => (\n                                    // loop edges will be circles rotated around offset\n                                    <Circle\n                                        id={id.toString()}\n                                        key={key}\n                                        x={x}\n                                        y={y}\n                                        width={width}\n                                        height={height}\n                                        stroke=\"black\"\n                                        strokeWidth={3}\n                                        draggable='true'\n                                        fill={fill}\n                                        onDragStart={this.handleDragStart}\n                                        onDragMove={this.updateLine}\n                                        onDragEnd={this.handleDragEnd}\n                                        onClick={this.addEdge}\n                                        name=\"node\"\n                                    />\n                                ))}\n                                {this.state.canvas.map(({ height, width, x, y, id, fill }, key) => (\n                                    <Text\n                                        id={\"label\" + id} // label corresponds to node id\n                                        x={id > 9 ? x - 9 : x - 4}\n                                        y={y - 5}\n                                        fontFamily='Lato, sans-serif'\n                                        fontStyle=\"bold\"\n                                        fontSize={15}\n                                        text={id.toString()}\n                                        listening={false}\n                                    />\n                                ))}\n                            </Layer>\n                            <Layer>\n                                <Group draggable={true}>\n                                    <Rect\n                                        x={window.innerWidth - 299}\n                                        y={35}\n                                        width={200}\n                                        height={100}\n                                        fill=\"white\"\n                                        shadowBlur={15}\n                                        shadowOpacity={.5}\n                                        shadowOffsetX={6}\n                                        shadowOffsetY={6}\n                                        cornerRadius={7}\n\n                                    />\n                                    <Text\n                                        x={window.innerWidth - 299}\n                                        y={40}\n                                        fontFamily='Lato, sans-serif'\n                                        fontSize={18}\n                                        fontStyle=\"bold\"\n                                        text={usefultext}\n                                        align='center'\n                                        lineHeight={1.3}\n                                        width={200}\n                                    />\n                                </Group>\n                            </Layer>\n                        </Stage>\n                    </div>\n                </div>\n            </div>\n        );\n    }\n}","import logo from './logo.svg';\nimport './App.css';\nimport MainCanvas from './components/canvas.js'\nimport { Stage, Layer, Rect, Text } from 'react-konva';\nimport Konva from 'konva';\nfunction App() {\n  \n  return (\n    <div className=\"App\">\n      <MainCanvas></MainCanvas>\n      \n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}