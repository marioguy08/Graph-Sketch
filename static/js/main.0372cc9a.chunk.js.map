{"version":3,"sources":["logo.svg","components/canvas.js","App.js","reportWebVitals.js","index.js"],"names":["counter","linecounter","loopcounter","minHeap","Heap","stageRef","React","createRef","MainCanvas","state","isBipartite","delete","color","numComponents","undirected","canvas","lines","loops","bridgeDict","showBridges","adjList","edgenodestart","generateNode","pos","newNode","length","id","pop","x","y","width","height","fill","handleClick","e","target","getStage","getPointerPosition","newnode","setState","prevState","genAdjlist","handleDragStart","moveToTop","to","shadowOffsetX","shadowOffsetY","shadowBlur","shadowColor","scaleX","scaleY","handleDragEnd","newnodes","nodeid","attrs","i","parseInt","newloops","duration","easing","Konva","Easings","ElasticEaseOut","addEdge","layer","current","nodedeleteid","nodedelete","findOne","find","linedeleteids","startid","endid","newlines","splice","push","undefined","label","newLoop","newloop","concat","flag","nodestart","nodestartx","nodestarty","nodeend","nodeendx","nodeendy","numlines","angle","radius","dx","dy","Math","atan2","cos","PI","sin","isgrouped","newline","points","groupnumber","updateLine","curpoints","editnode","loop","position","returnundirected","selfid","startend","findBridges","visited","queue","adjDict","curnode","shift","topologicalSort","processed","visiting","stack","node","dfs","reverse","cyclecheck","output","colors","initTime","lowestAncestor","parent","timer","child","min","j","deleteLine","deleteLoop","changeUndirected","val","createntries","JSXadjList","className","style","margin","minWidth","neighborlist","toString","letterSpacing","key","keyrev","topologicalordering","this","slice","usefultext","display","flexDirection","boxShadow","justifyContent","marginRight","type","readOnly","checked","onClick","backgroundColor","padding","textAlign","listStyleType","window","innerWidth","innerHeight","ref","left","map","radiusX","radiusY","stroke","strokeWidth","name","pointerWidth","draggable","onDragStart","onDragMove","onDragEnd","fontFamily","fontStyle","fontSize","text","listening","shadowOpacity","cornerRadius","align","lineHeight","Component","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.0372cc9a.chunk.js","sourcesContent":["export default __webpack_public_path__ + \"static/media/logo.6ce24c58.svg\";","import React, { Component } from \"react\";\r\nimport Konva from \"konva\";\r\nimport { Stage, Layer, Ellipse, Circle, Line, Arrow, Text, Rect, Group } from \"react-konva\";\r\nimport Heap from 'heap-js';\r\n\r\nvar counter = 1;\r\nvar linecounter = 1;\r\nvar loopcounter = 1;\r\nconst minHeap = new Heap();\r\nconst stageRef = React.createRef();\r\n\r\nexport default class MainCanvas extends Component {\r\n    state = {\r\n        isBipartite: true,\r\n        delete: false,\r\n        color: false,\r\n        numComponents: 0,\r\n        undirected: true,\r\n        canvas: [],\r\n        lines: [],\r\n        loops: [],\r\n        bridgeDict: {},\r\n        showBridges: false,\r\n        adjList: {},\r\n        edgenodestart: [null, null, null],\r\n    };\r\n\r\n    generateNode = (pos) => {\r\n        var newNode = {};\r\n        if (minHeap.length > 0) {\r\n            var newid = minHeap.pop();\r\n            newNode = {\r\n                id: newid,\r\n                x: pos.x,\r\n                y: pos.y,\r\n                width: 40,\r\n                height: 40,\r\n                fill: \"white\"\r\n            }\r\n            counter -= 1;\r\n        } else {\r\n            newNode = {\r\n                id: counter,\r\n                x: pos.x,\r\n                y: pos.y,\r\n                width: 40,\r\n                height: 40,\r\n                fill: \"white\"\r\n            }\r\n        }\r\n        return newNode;\r\n    }\r\n\r\n    handleClick = (e) => {\r\n        if (this.state.delete != true) {\r\n            const emptySpace = e.target === e.target.getStage();\r\n            if (!emptySpace) {\r\n                return;\r\n            }\r\n            const pos = e.target.getStage().getPointerPosition();\r\n            var newnode = this.generateNode(pos);\r\n            counter += 1\r\n            this.setState(prevState => ({\r\n                canvas: [...prevState.canvas, { ...newnode }],\r\n                edgenodestart: [null, null, null]\r\n\r\n            }), () => this.genAdjlist());\r\n        }\r\n    };\r\n\r\n    handleDragStart = e => {\r\n        e.target.moveToTop();\r\n        e.target.to({\r\n            shadowOffsetX: 0,\r\n            shadowOffsetY: 0,\r\n            shadowBlur: 10,\r\n            shadowColor: \"black\",\r\n            scaleX: 1.15,\r\n            scaleY: 1.15,\r\n        });\r\n    };\r\n\r\n    handleDragEnd = e => {\r\n        var newnodes = [...this.state.canvas];\r\n        var nodeid = e.target.attrs.id;\r\n        for (var i = 0; i < newnodes.length; i += 1) {\r\n            if (newnodes[i].id === parseInt(nodeid)) {\r\n                newnodes[i].x = e.target.attrs.x;\r\n                newnodes[i].y = e.target.attrs.y;\r\n                break;\r\n            }\r\n        }\r\n        var newloops = [...this.state.loops];\r\n        for (var i = 0; i < newloops.length; i += 1) {\r\n            if (newloops[i].nodeid === nodeid) {\r\n                newloops[i].x = e.target.attrs.x;\r\n                newloops[i].y = e.target.attrs.y - 40;\r\n                break;\r\n            }\r\n        }\r\n        this.setState({\r\n            loops: newloops,\r\n            canvas: newnodes\r\n        })\r\n        e.target.to({\r\n            duration: 0.5,\r\n            easing: Konva.Easings.ElasticEaseOut,\r\n            scaleX: 1,\r\n            scaleY: 1,\r\n            shadowBlur: 0,\r\n        });\r\n    };\r\n    addEdge = (e) => {\r\n        if (this.state.color === true && this.state.delete == false) {\r\n            var newnodes = [...this.state.canvas];\r\n            for (var i = 0; i < newnodes.length; i += 1) {\r\n                if ((newnodes[i].id) === parseInt(e.target.attrs.id)) {\r\n                    if (newnodes[i].fill === \"white\") {\r\n                        newnodes[i].fill = \"#007bff\"\r\n                    }\r\n                    else if (newnodes[i].fill === \"#007bff\") {\r\n                        newnodes[i].fill = \"#ff5353\"\r\n                    }\r\n                    else {\r\n                        newnodes[i].fill = \"white\"\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n            this.setState({\r\n                canvas: newnodes,\r\n                edgenodestart: [null, null, null]\r\n            })\r\n            return;\r\n        }\r\n        var layer = stageRef.current;\r\n        if (this.state.delete === true) {\r\n            var nodedeleteid = e.target.attrs.id;\r\n            var nodedelete = layer.findOne('#' + e.target.attrs.id);\r\n            var lines = layer.find('.line');\r\n            var linedeleteids = {};\r\n            for (i = 0; i < lines.length; i += 1) {\r\n                if (lines[i].attrs.startid === nodedelete.attrs.id || lines[i].attrs.endid === nodedelete.attrs.id) {\r\n                    linedeleteids[lines[i].attrs.id] = true;\r\n                }\r\n            }\r\n            var newlines = [...this.state.lines];\r\n            for (var i = newlines.length - 1; i > -1; i -= 1) {\r\n                if ((\"line\" + newlines[i].id) in linedeleteids) {\r\n                    newlines.splice(i, 1);\r\n                }\r\n            }\r\n            this.setState({\r\n                lines: newlines\r\n            })\r\n            var newnodes = [...this.state.canvas];\r\n            for (var i = 0; i < newnodes.length; i += 1) {\r\n                if (parseInt(newnodes[i].id) === parseInt(nodedelete.attrs.id)) {\r\n                    newnodes.splice(i, 1);\r\n                    break;\r\n                }\r\n            }\r\n            this.setState({\r\n                canvas: newnodes\r\n            })\r\n            minHeap.push(parseInt(nodedeleteid));\r\n            var newloops = [...this.state.loops];\r\n            for (var i = 0; i < newloops.length; i += 1) {\r\n                if ((newloops[i].nodeid) === nodedeleteid) {\r\n                    newloops.splice(i, 1);\r\n                    break;\r\n                }\r\n            }\r\n            this.setState({\r\n                loops: newloops\r\n            }, () => this.genAdjlist());\r\n            this.setState({\r\n                edgenodestart: [null, null, null]\r\n            })\r\n            return;\r\n        }\r\n        if (this.state.edgenodestart[0] == null) {\r\n            this.setState({\r\n                edgenodestart: [e.target.attrs.id, e.target.attrs.x, e.target.attrs.y]\r\n            })\r\n        } else {\r\n            if (e.target.attrs.id === this.state.edgenodestart[0]) { // create loop\r\n                var prevloop = layer.findOne('#loop' + e.target.attrs.id); // check if there is already loop\r\n                if (prevloop === undefined) {\r\n                    this.setState({\r\n                        edgenodestart: [null, null, null]\r\n                    })\r\n                    var label = layer.findOne('#label' + e.target.attrs.id);\r\n                    e.target.moveToTop();\r\n                    label.moveToTop();\r\n                    var newLoop = {\r\n                        nodeid: e.target.attrs.id,\r\n                        id: loopcounter,\r\n                        x: e.target.attrs.x,\r\n                        y: e.target.attrs.y - 40,\r\n                        width: 25,\r\n                        height: 40\r\n                    }\r\n                    loopcounter += 1;\r\n                    var newloop = this.state.loops.concat(newLoop);\r\n                    this.setState({ loops: newloop }, () => this.genAdjlist())\r\n                    this.setState({\r\n                        edgenodestart: [null, null, null]\r\n                    })\r\n                    return\r\n                }\r\n                this.setState({\r\n                    edgenodestart: [null, null, null]\r\n                })\r\n                return\r\n            }\r\n            var flag = 0;\r\n            var nodestart = this.state.edgenodestart[0];\r\n            var nodestartx = this.state.edgenodestart[1];\r\n            var nodestarty = this.state.edgenodestart[2];\r\n            var nodeend = e.target.attrs.id;\r\n            var nodeendx = e.target.attrs.x;\r\n            var nodeendy = e.target.attrs.y;\r\n            var lines = layer.find('.line');\r\n            var numlines = 0;\r\n            var i = 0\r\n            for (i = 0; i < lines.length; i += 1) {\r\n                if ((lines[i].attrs.startid === nodestart && lines[i].attrs.endid === nodeend) || (lines[i].attrs.startid === nodeend && lines[i].attrs.endid === nodestart)) {\r\n\r\n                    flag = 1;\r\n                    numlines += 1;\r\n                }\r\n            }\r\n            const radius = -50;\r\n            let angle = 0;\r\n            var flag = 0;\r\n            if (nodestartx >= nodeendx) {\r\n                flag = 1;\r\n            }\r\n            const dx = nodestartx - nodeendx;\r\n            const dy = nodestarty - nodeendy;\r\n            angle = Math.atan2(-dy, dx);\r\n            if (numlines === 0) {\r\n                nodestartx = nodestartx + -radius * (Math.cos(angle + Math.PI) * .5);\r\n                nodestarty = nodestarty + radius * (Math.sin(angle + Math.PI) * .5);\r\n                nodeendx = nodeendx + -radius * (Math.cos(angle) * .5);\r\n                nodeendy = nodeendy + radius * (Math.sin(angle) * .5);\r\n            }\r\n            else if (numlines === 1) {\r\n                if (flag != 1) {\r\n                    nodestartx = nodestartx + -radius * (Math.cos(angle + Math.PI - .5) * .5);\r\n                    nodestarty = nodestarty + radius * (Math.sin(angle + Math.PI - .5) * .5);\r\n                    nodeendx = nodeendx + -radius * (Math.cos(angle + .5) * .5);\r\n                    nodeendy = nodeendy + radius * (Math.sin(angle + .5) * .5);\r\n                } else {\r\n                    nodestartx = nodestartx + -radius * (Math.cos(angle + Math.PI + .5) * .5);\r\n                    nodestarty = nodestarty + radius * (Math.sin(angle + Math.PI + .5) * .5);\r\n                    nodeendx = nodeendx + -radius * (Math.cos(angle - .5) * .5);\r\n                    nodeendy = nodeendy + radius * (Math.sin(angle - .5) * .5);\r\n                }\r\n            }\r\n            else if (numlines === 2) {\r\n\r\n                if (flag != 1) {\r\n                    nodestartx = nodestartx + -radius * (Math.cos(angle + Math.PI + .5) * .5);\r\n                    nodestarty = nodestarty + radius * (Math.sin(angle + Math.PI + .5) * .5);\r\n                    nodeendx = nodeendx + -radius * (Math.cos(angle - .5) * .5);\r\n                    nodeendy = nodeendy + radius * (Math.sin(angle - .5) * .5);\r\n                } else {\r\n                    nodestartx = nodestartx + -radius * (Math.cos(angle + Math.PI - .5) * .5);\r\n                    nodestarty = nodestarty + radius * (Math.sin(angle + Math.PI - .5) * .5);\r\n                    nodeendx = nodeendx + -radius * (Math.cos(angle + .5) * .5);\r\n                    nodeendy = nodeendy + radius * (Math.sin(angle + .5) * .5);\r\n                };\r\n            }\r\n            else {\r\n                this.setState({\r\n                    edgenodestart: [null, null, null]\r\n                })\r\n                return;\r\n            }\r\n\r\n            var isgrouped = false;\r\n            var groupnumber = numlines + 1;\r\n            if (numlines > 0) {\r\n                isgrouped = true;\r\n            }\r\n            var newline = {\r\n                id: linecounter,\r\n                startid: nodestart,\r\n                endid: nodeend,\r\n                points: [nodestartx, nodestarty, nodeendx, nodeendy],\r\n                isgrouped: isgrouped,\r\n                fill: 'black',\r\n                groupnumber: groupnumber\r\n            }\r\n            this.setState(prevState => ({\r\n                lines: [...prevState.lines, { ...newline }]\r\n            }), () => this.genAdjlist());\r\n            this.setState({\r\n                edgenodestart: [null, null, null]\r\n            })\r\n            linecounter += 1;\r\n\r\n        }\r\n\r\n    }\r\n\r\n    updateLine = (e) => {\r\n        var nodeid = e.target.attrs.id;\r\n        var layer = stageRef.current;\r\n        //UPDATE ALL LINES\r\n        var lines = layer.find('.line');\r\n        for (var i = 0; i < lines.length; i += 1) {\r\n            if (lines[i].attrs.startid === nodeid) {\r\n                var nodestart = layer.findOne('#' + lines[i].attrs.startid);\r\n                var nodeend = layer.findOne('#' + lines[i].attrs.endid);\r\n                var flag = 0;\r\n                var nodestartx = nodestart.attrs.x;\r\n                var nodestarty = nodestart.attrs.y;\r\n                var nodeendx = nodeend.attrs.x;\r\n                var nodeendy = nodeend.attrs.y;\r\n                if (nodestartx >= nodeendx) {\r\n                    flag = 1;\r\n                }\r\n                const radius = -50;\r\n                const dx = nodestartx - nodeendx;\r\n                const dy = nodestarty - nodeendy;\r\n                let angle = Math.atan2(-dy, dx);\r\n                if (lines[i].attrs.groupnumber === 1 || lines[i].attrs.isgrouped === false) {\r\n                    var curpoints = lines[i].attrs.points\r\n                    nodestartx = e.target.attrs.x + -radius * (Math.cos(angle + Math.PI) * .5);\r\n                    nodestarty = e.target.attrs.y + radius * (Math.sin(angle + Math.PI) * .5);\r\n                    nodeendx = nodeendx + -radius * (Math.cos(angle) * .5);\r\n                    nodeendy = nodeendy + radius * (Math.sin(angle) * .5);\r\n                    curpoints[0] = nodestartx;\r\n                    curpoints[1] = nodestarty;\r\n                    curpoints[2] = nodeendx;\r\n                    curpoints[3] = nodeendy;\r\n                    lines[i].attrs.points = curpoints;\r\n                }\r\n                else if (lines[i].attrs.groupnumber === 2) {\r\n                    if (flag != 1) {\r\n                        nodestartx = nodestartx + -radius * (Math.cos(angle + Math.PI - .5) * .5);\r\n                        nodestarty = nodestarty + radius * (Math.sin(angle + Math.PI - .5) * .5);\r\n                        nodeendx = nodeendx + -radius * (Math.cos(angle + .5) * .5);\r\n                        nodeendy = nodeendy + radius * (Math.sin(angle + .5) * .5);\r\n                    } else {\r\n                        nodestartx = nodestartx + -radius * (Math.cos(angle + Math.PI + .5) * .5);\r\n                        nodestarty = nodestarty + radius * (Math.sin(angle + Math.PI + .5) * .5);\r\n                        nodeendx = nodeendx + -radius * (Math.cos(angle - .5) * .5);\r\n                        nodeendy = nodeendy + radius * (Math.sin(angle - .5) * .5);\r\n                    }\r\n\r\n                    var curpoints = lines[i].attrs.points\r\n                    curpoints[0] = nodestartx;\r\n                    curpoints[1] = nodestarty;\r\n                    curpoints[2] = nodeendx;\r\n                    curpoints[3] = nodeendy;\r\n                    lines[i].attrs.points = curpoints;\r\n                }\r\n                else if (lines[i].attrs.groupnumber === 3) {\r\n                    if (flag != 1) {\r\n                        nodestartx = nodestartx + -radius * (Math.cos(angle + Math.PI + .5) * .5);\r\n                        nodestarty = nodestarty + radius * (Math.sin(angle + Math.PI + .5) * .5);\r\n                        nodeendx = nodeendx + -radius * (Math.cos(angle - .5) * .5);\r\n                        nodeendy = nodeendy + radius * (Math.sin(angle - .5) * .5);\r\n                    } else {\r\n                        nodestartx = nodestartx + -radius * (Math.cos(angle + Math.PI - .5) * .5);\r\n                        nodestarty = nodestarty + radius * (Math.sin(angle + Math.PI - .5) * .5);\r\n                        nodeendx = nodeendx + -radius * (Math.cos(angle + .5) * .5);\r\n                        nodeendy = nodeendy + radius * (Math.sin(angle + .5) * .5);\r\n                    }\r\n\r\n                    var curpoints = lines[i].attrs.points\r\n                    curpoints[0] = nodestartx;\r\n                    curpoints[1] = nodestarty;\r\n                    curpoints[2] = nodeendx;\r\n                    curpoints[3] = nodeendy;\r\n                    lines[i].attrs.points = curpoints;\r\n                }\r\n            }\r\n            if (lines[i].attrs.endid === nodeid) {\r\n                var nodestart = layer.findOne('#' + lines[i].attrs.startid);\r\n                var nodeend = layer.findOne('#' + lines[i].attrs.endid);\r\n                var nodestartx = nodestart.attrs.x;\r\n                var nodestarty = nodestart.attrs.y;\r\n                var nodeendx = nodeend.attrs.x;\r\n                var nodeendy = nodeend.attrs.y;\r\n                const radius = -50;\r\n                var flag = 0;\r\n                var nodestartx = nodestart.attrs.x;\r\n                var nodestarty = nodestart.attrs.y;\r\n                var nodeendx = nodeend.attrs.x;\r\n                var nodeendy = nodeend.attrs.y;\r\n                if (nodestartx >= nodeendx) {\r\n                    flag = 1;\r\n                }\r\n                const dx = nodestartx - nodeendx;\r\n                const dy = nodestarty - nodeendy;\r\n                let angle = Math.atan2(-dy, dx);\r\n\r\n                if (lines[i].attrs.groupnumber === 1 || lines[i].attrs.isgrouped === false) {\r\n                    var curpoints = lines[i].attrs.points\r\n                    nodestartx = nodestartx + -radius * (Math.cos(angle + Math.PI) * .5);\r\n                    nodestarty = nodestarty + radius * (Math.sin(angle + Math.PI) * .5);\r\n                    nodeendx = nodeendx + -radius * (Math.cos(angle) * .5);\r\n                    nodeendy = nodeendy + radius * (Math.sin(angle) * .5);\r\n\r\n                    curpoints[2] = nodeendx;\r\n                    curpoints[3] = nodeendy;\r\n                    curpoints[0] = nodestartx;\r\n                    curpoints[1] = nodestarty;\r\n                    lines[i].attrs.points = curpoints;\r\n                }\r\n                else if (lines[i].attrs.groupnumber === 2) {\r\n                    if (flag != 1) {\r\n                        nodestartx = nodestartx + -radius * (Math.cos(angle + Math.PI - .5) * .5);\r\n                        nodestarty = nodestarty + radius * (Math.sin(angle + Math.PI - .5) * .5);\r\n                        nodeendx = nodeendx + -radius * (Math.cos(angle + .5) * .5);\r\n                        nodeendy = nodeendy + radius * (Math.sin(angle + .5) * .5);\r\n                    } else {\r\n                        nodestartx = nodestartx + -radius * (Math.cos(angle + Math.PI + .5) * .5);\r\n                        nodestarty = nodestarty + radius * (Math.sin(angle + Math.PI + .5) * .5);\r\n                        nodeendx = nodeendx + -radius * (Math.cos(angle - .5) * .5);\r\n                        nodeendy = nodeendy + radius * (Math.sin(angle - .5) * .5);\r\n                    }\r\n                    var curpoints = lines[i].attrs.points\r\n                    curpoints[0] = nodestartx;\r\n                    curpoints[1] = nodestarty;\r\n                    curpoints[2] = nodeendx;\r\n                    curpoints[3] = nodeendy;\r\n                    lines[i].attrs.points = curpoints;\r\n                }\r\n                else if (lines[i].attrs.groupnumber === 3) {\r\n                    if (flag != 1) {\r\n                        nodestartx = nodestartx + -radius * (Math.cos(angle + Math.PI + .5) * .5);\r\n                        nodestarty = nodestarty + radius * (Math.sin(angle + Math.PI + .5) * .5);\r\n                        nodeendx = nodeendx + -radius * (Math.cos(angle - .5) * .5);\r\n                        nodeendy = nodeendy + radius * (Math.sin(angle - .5) * .5);\r\n                    } else {\r\n                        nodestartx = nodestartx + -radius * (Math.cos(angle + Math.PI - .5) * .5);\r\n                        nodestarty = nodestarty + radius * (Math.sin(angle + Math.PI - .5) * .5);\r\n                        nodeendx = nodeendx + -radius * (Math.cos(angle + .5) * .5);\r\n                        nodeendy = nodeendy + radius * (Math.sin(angle + .5) * .5);\r\n                    }\r\n\r\n                    var curpoints = lines[i].attrs.points\r\n                    curpoints[0] = nodestartx;\r\n                    curpoints[1] = nodestarty;\r\n                    curpoints[2] = nodeendx;\r\n                    curpoints[3] = nodeendy;\r\n                    lines[i].attrs.points = curpoints;\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n        // update position of loops and labels\r\n        var editnode = layer.findOne('#' + nodeid);\r\n        var loop = layer.findOne('#loop' + nodeid);\r\n        if (loop) {\r\n            loop.position({ x: editnode.attrs.x, y: editnode.attrs.y - 40 })\r\n        }\r\n        var label = layer.findOne('#label' + nodeid);\r\n        if (label) {\r\n            label.moveToTop();\r\n            label.position({ x: nodeid > 9 ? editnode.attrs.x - 9 : editnode.attrs.x - 4, y: editnode.attrs.y - 5 });\r\n        }\r\n    }\r\n\r\n    genAdjlist = (returnundirected) => {\r\n        var layer = stageRef.current;\r\n        var lines = layer.find('.line');\r\n        var adjList = {};\r\n        for (var i = 0; i < this.state.canvas.length; i += 1) {\r\n            adjList[this.state.canvas[i].id] = [];\r\n        }\r\n        for (var i = 0; i < this.state.loops.length; i += 1) {\r\n            var selfid = this.state.loops[i].nodeid;\r\n            adjList[selfid].push(selfid);\r\n        }\r\n        for (var i = 0; i < lines.length; i += 1) {\r\n            var startend = [lines[i].attrs.startid, lines[i].attrs.endid];\r\n            adjList[startend[0]].push(parseInt(startend[1]));\r\n            if (this.state.undirected === true || returnundirected === true) {\r\n                adjList[startend[1]].push(parseInt(startend[0]));\r\n            }\r\n        }\r\n        if (!returnundirected) {\r\n            this.setState({ adjList: adjList }, () => {\r\n                this.isBipartite();\r\n                this.numComponents();\r\n                this.findBridges();\r\n            }\r\n            );\r\n        }\r\n        if (returnundirected === true) {\r\n            return adjList;\r\n        }\r\n    }\r\n\r\n    numComponents = () => {\r\n        var numComponents = 0;\r\n        var visited = {};\r\n        var queue = [];\r\n        for (const adjDict in this.state.adjList) {\r\n            if (adjDict in visited === false) {\r\n                numComponents += 1;\r\n                queue.push(adjDict);\r\n                visited[adjDict] = true;\r\n                while (queue.length > 0) {\r\n                    var curnode = queue.shift();\r\n                    for (var i = 0; i < this.state.adjList[curnode].length; i += 1) {\r\n                        if (this.state.adjList[curnode][i] in visited === false) {\r\n                            queue.push(this.state.adjList[curnode][i]);\r\n                            visited[this.state.adjList[curnode][i]] = true;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this.setState({\r\n            numComponents: numComponents\r\n        })\r\n    }\r\n\r\n    topologicalSort = () => {\r\n        var processed = {};\r\n        var visiting = {};\r\n        var stack = [];\r\n        for (var node in this.state.adjList) {\r\n            if (node in processed != true) {\r\n\r\n                if (dfs(node, visiting, processed, stack, this.state.adjList)) {\r\n                    return [];\r\n                }\r\n            }\r\n        }\r\n        stack.reverse()\r\n        return stack;\r\n        function dfs(node, cyclecheck, processed, output, adjList) {\r\n            if (node in processed) {\r\n                return false;\r\n            }\r\n            if (node in cyclecheck) {\r\n                return true; // we want to bubble up true in case there is cycle in directed graph.\r\n            }\r\n            cyclecheck[node] = true;\r\n            for (var i = 0; i < adjList[node].length; i += 1) {\r\n                var foundcycle = dfs(adjList[node][i], cyclecheck, processed, output, adjList);\r\n                if (foundcycle) {\r\n                    return true;\r\n                }\r\n            }\r\n            delete cyclecheck[node];\r\n            processed[node] = true;\r\n            output.push(\",\");\r\n            output.push(parseInt(node));\r\n            return false\r\n        }\r\n    }\r\n\r\n    isBipartite = () => {\r\n        var isBipartite = true;\r\n        if (this.state.lines.length === 0 && this.state.loops.length === 0) {\r\n            //dont do anything if there arent any edges\r\n        } else {\r\n            if (this.state.undirected === false) { // we always want to treat the graph as undirected when checking if it is bipartite\r\n                var adjList = this.genAdjlist(true);\r\n            } else {\r\n                var adjList = this.state.adjList;\r\n            }\r\n            let colors = {}; // will store the color of each node with false and true\r\n            for (var adjDict in this.state.adjList) {\r\n                if (adjDict in colors === false) {// only do bfs on nodes that werent visited\r\n                    var queue = [] // queue for breadth first search\r\n                    queue.push([adjDict, false, -1]);\r\n                    colors[adjDict] = false; // mark visited\r\n                    while (queue.length > 0) {\r\n                        var curnode = queue.shift();// pop first node by shifting array\r\n                        for (var i = 0; i < adjList[curnode[0]].length; i += 1) {\r\n                            if (adjList[curnode[0]][i] === curnode[2]) {\r\n                                // we dont want to go back to the neighbor we previosly visited\r\n                                continue;\r\n                            }\r\n                            if (adjList[curnode[0]][i] in colors === true && colors[adjList[curnode[0]][i]] != curnode[1]) {\r\n                                // in case we reach node that is visited but is the opposite color then we also know the rest of its neighbors and so on are bipartite\r\n                                continue;\r\n                            }\r\n                            if (adjList[curnode[0]][i] in colors === true && colors[adjList[curnode[0]][i]] === curnode[1]) {\r\n                                // in case we reach a visited node that wasnt started on and its color is the same as the current color then not bipartite\r\n                                isBipartite = false;\r\n                                break;\r\n                            }\r\n                            // push neighbor to queue\r\n                            colors[adjList[curnode[0]][i]] = !curnode[1]; // mark visited\r\n                            queue.push([adjList[curnode[0]][i], !curnode[1], curnode[0]]);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this.setState({\r\n            isBipartite: isBipartite\r\n        });\r\n    }\r\n\r\n    findBridges = () => {\r\n        var bridgeDict = {};\r\n        if (this.state.undirected === true && this.state.showBridges === true) {\r\n            var initTime = {};\r\n            var lowestAncestor = {};\r\n            var timer = 1;\r\n            for (var node in this.state.adjList) {\r\n                if (node in initTime === false) {\r\n                    // do dfs if not visited\r\n                    dfs(parseInt(node), -1, initTime, lowestAncestor, timer, this.state.adjList);\r\n                }\r\n            }\r\n        }\r\n        this.setState({\r\n            bridgeDict: bridgeDict\r\n        }, () => this.showBridges());\r\n        function dfs(node, parent, initTime, lowestAncestor, timer, adjList) {\r\n            initTime[node] = timer;\r\n            lowestAncestor[node] = timer;\r\n            timer += 1\r\n            if (adjList[node] != []) {\r\n                for (var child = 0; child < adjList[node].length; child += 1) {\r\n                    if (adjList[node][child] === parent) { // dont go back to parent\r\n                        continue;\r\n                    }\r\n                    else if (adjList[node][child] in initTime) {// found visited node so update low of curnode if it is \r\n                        lowestAncestor[node] = Math.min(initTime[adjList[node][child]], lowestAncestor[node])\r\n                    } else {// child not visited\r\n                        dfs(adjList[node][child], node, initTime, lowestAncestor, timer, adjList);\r\n                        if (lowestAncestor[adjList[node][child]] > initTime[node]) {// if only way to child is from parent then it is bridge\r\n                            //checks for parallel edges since it wont be a bridge if there is another edge\r\n                            var counter = 0;\r\n                            for (var j = 0; j < adjList[node].length; j += 1) {\r\n                                if (adjList[node][j] === adjList[node][child]) {\r\n                                    counter += 1;\r\n                                }\r\n                            }\r\n                            if (counter < 2) { // if no other edge going from node to child other than one, then its a bridge.\r\n                                bridgeDict[[node, adjList[node][child]]] = true;\r\n                            }\r\n                        } else { // otherwise update the lowest ancestor reachable from current node ny seeing if the childs lowest acnestor is lower\r\n                            lowestAncestor[node] = Math.min(lowestAncestor[node], lowestAncestor[adjList[node][child]]);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    deleteLine = (e) => {\r\n        var newlines = [...this.state.lines];\r\n        for (var i = 0; i < newlines.length; i += 1) {\r\n            if (\"line\" + newlines[i].id === e.target.attrs.id) {\r\n                newlines.splice(i, 1);\r\n                break;\r\n            }\r\n        }\r\n        this.setState({\r\n            lines: newlines\r\n        }, () => this.genAdjlist());\r\n    }\r\n\r\n    deleteLoop = (e) => {\r\n        var newloops = [...this.state.loops];\r\n        for (var i = 0; i < newloops.length; i += 1) {\r\n            if ((\"loop\" + newloops[i].nodeid) === e.target.attrs.id) {\r\n                newloops.splice(i, 1);\r\n                break;\r\n            }\r\n        }\r\n        this.setState({\r\n            loops: newloops\r\n        }, () => this.genAdjlist())\r\n    }\r\n\r\n    changeUndirected = (val) => {\r\n        if (val) {\r\n            this.setState((prevState) => ({ undirected: true }), () => this.genAdjlist());\r\n        } else {\r\n            this.setState((prevState) => ({ undirected: false }), () => this.genAdjlist());\r\n        }\r\n\r\n    }\r\n\r\n    createntries = () => {\r\n        var JSXadjList = [];\r\n        JSXadjList.push(<li className=\"listitems\" key={node} style={{ margin: \"13px\", minWidth: \"110px\" }}>Adjacency List:</li>);\r\n        for (var node in this.state.adjList) {\r\n            var neighborlist = [];\r\n            for (var i = 0; i < this.state.adjList[node].length; i += 1) {\r\n                neighborlist.push(this.state.adjList[node][i]);\r\n            }\r\n            neighborlist = neighborlist.toString();\r\n            JSXadjList.push(<li className=\"listitems\" key={node} style={{ margin: \"13px\", minWidth: \"110px\", letterSpacing: \"2px\" }}>{node}:{neighborlist}</li>);\r\n        }\r\n        return JSXadjList;\r\n    }\r\n\r\n    showBridges = () => {\r\n        var lines = this.state.lines;\r\n        for (var i = 0; i < lines.length; i += 1) {\r\n            if (this.state.undirected === true) {\r\n                var key = lines[i].startid.toString() + \",\" + lines[i].endid.toString();\r\n                var keyrev = lines[i].endid.toString() + \",\" + lines[i].startid.toString();\r\n                if (key in this.state.bridgeDict || keyrev in this.state.bridgeDict) {\r\n                    lines[i].fill = 'red';\r\n                } else {\r\n                    lines[i].fill = 'black';\r\n                }\r\n            } else {\r\n                lines[i].fill = 'black';\r\n            }\r\n        }\r\n        this.setState({\r\n            lines: lines\r\n        })\r\n    }\r\n\r\n    render() {\r\n        var topologicalordering = this.topologicalSort();\r\n        topologicalordering.slice(-1)\r\n        if (topologicalordering.length < 1 && this.state.canvas.length > 0) {\r\n            topologicalordering = \"Cycle Detected!\"\r\n        }\r\n        var JSXadjList = this.createntries();\r\n        var usefultext = (this.state.isBipartite ? \"Bipartite: True\\n\" : \"Bipartite: False\\n\") +\r\n            (\"Components: \" + (this.state.undirected ? this.state.numComponents : \"N/A\") + \"\\n\") +\r\n            (\"V: \" + (this.state.canvas.length) + \"\\n\") +\r\n            (\"E: \" + (this.state.lines.length + this.state.loops.length));\r\n        return (\r\n            <div>\r\n                <div style={{ display: \"flex\", flexDirection: \"row\", boxShadow: \"rgba(0, 0, 0, 0.15) 1.95px 1.95px 2.6px\", justifyContent: \"space-between\" }}>\r\n                    <h1 className=\"titletext\">Graph Sketcher</h1>\r\n                    <div style={{ display: \"flex\", flexDirection: \"row\", marginRight: \"5rem\" }}>\r\n                        {\r\n                            this.state.undirected === true ?\r\n                                <p className='checktext'>Show Bridges <input type=\"checkbox\" readOnly={true} className='checkbox' checked={this.state.showBridges === true ? true : false} onClick={() => this.setState((prevState) => ({ showBridges: !prevState.showBridges }), () => this.genAdjlist())}></input></p>\r\n                                :\r\n                                null\r\n                        }\r\n                        <div style={{ display: \"flex\", flexDirection: \"row\" }}>\r\n                            <button className=\"optionsbuttons left\" style={this.state.delete === false && this.state.color == false ? { backgroundColor: \"#272942\" } : { backgroundColor: \"#4a508b\" }} onClick={() => this.setState({ delete: false, color: false })}>DRAW</button>\r\n                            <button className=\"optionsbuttons\" style={this.state.delete === true ? { backgroundColor: \"#272942\" } : { backgroundColor: \"#4a508b\" }} onClick={() => this.setState({ delete: true, color: false })}>DELETE</button>\r\n                            <button className=\"optionsbuttons right\" style={this.state.delete === false && this.state.color == true ? { backgroundColor: \"#272942\" } : { backgroundColor: \"#4a508b\" }} onClick={() => this.setState({ color: true, delete: false })}>COLOR</button>\r\n                        </div>\r\n                        &nbsp;\r\n                        <div style={{ display: \"flex\", flexDirection: \"row\" }}>\r\n                            <button className=\"optionsbuttons left\" style={this.state.undirected ? { backgroundColor: \"#272942\" } : { backgroundColor: \"#4a508b\" }} onClick={() => this.changeUndirected(true)}>UNDIRECTED</button>\r\n                            <button className=\"optionsbuttons right\" style={this.state.undirected ? { backgroundColor: \"#4a508b\" } : { backgroundColor: \"#272942\" }} onClick={() => this.changeUndirected(false)}>DIRECTED</button>\r\n                        </div>\r\n                    </div>\r\n                </div>\r\n                <div >\r\n                    <div style={{ display: \"flex\", flexDirection: \"row\" }}>\r\n                        <div style={{ display: \"flex\", flexDirection: \"row\" }}>\r\n                            <ul className=\"adjListContainer\" style={{ height: \"100%\", padding: \"0px\", margin: \"0px\", textAlign: \"left\", boxShadow: \"rgba(0, 0, 0, 0.15) 1.95px 1.95px 2.6px\", listStyleType: \"none\" }}>\r\n                                {JSXadjList}\r\n                            </ul>\r\n                            {\r\n                                this.state.undirected === false ?\r\n                                    <p className=\"topo\" style={{ boxShadow: \"rgba(0, 0, 0, 0.15) 1.95px 1.95px 2.6px\" }}>Topological Ordering: {topologicalordering}</p>\r\n                                    :\r\n                                    null\r\n                            }\r\n                        </div>\r\n                        <Stage width={window.innerWidth - 20} height={window.innerHeight + 400} onClick={this.handleClick} ref={stageRef} style={{ left: 0, position: \"absolute\" }}  >\r\n                            <Layer>\r\n                                {this.state.loops.map(({ id, x, y, width, height, nodeid }, key) => ( // like a \"for loop\", this maps over this.state.canvas objects and pulls out the height, width, x, y properties to be used below\r\n                                    // loop edges will be circles rotated around offset\r\n                                    <Ellipse\r\n                                        id={\"loop\" + nodeid}\r\n                                        nodeid={nodeid}\r\n                                        key={key}\r\n                                        x={x}\r\n                                        y={y}\r\n                                        radiusX={width}\r\n                                        radiusY={height}\r\n                                        stroke='black'\r\n                                        strokeWidth={3}\r\n                                        onClick={this.deleteLoop}\r\n                                    />\r\n                                ))}\r\n                                {this.state.lines.map(({ points, startid, endid, isgrouped, groupnumber, id, fill }, key) => ( // like a \"for loop\", this maps over this.state.canvas objects and pulls out the height, width, x, y properties to be used below\r\n                                    this.state.undirected ?\r\n                                        <Line\r\n                                            id={\"line\" + id}\r\n                                            key={key}\r\n                                            startid={startid}\r\n                                            endid={endid}\r\n                                            points={points}\r\n                                            stroke={fill}\r\n                                            strokeWidth={4}\r\n                                            isgrouped={isgrouped}\r\n                                            groupnumber={groupnumber}\r\n                                            name=\"line\"\r\n                                            onClick={this.deleteLine}\r\n                                        />\r\n                                        :\r\n                                        <Arrow\r\n                                            id={\"line\" + id}\r\n                                            key={key}\r\n                                            startid={startid}\r\n                                            endid={endid}\r\n                                            points={points}\r\n                                            stroke={fill}\r\n                                            strokeWidth={4}\r\n                                            isgrouped={isgrouped}\r\n                                            groupnumber={groupnumber}\r\n                                            name=\"line\"\r\n                                            pointerWidth={7}\r\n                                            fill=\"black\"\r\n                                            onClick={this.deleteLine}\r\n                                        />\r\n                                ))}\r\n                                {this.state.canvas.map(({ height, width, x, y, id, fill }, key) => (\r\n                                    // loop edges will be circles rotated around offset\r\n                                    <Circle\r\n                                        id={id.toString()}\r\n                                        key={key}\r\n                                        x={x}\r\n                                        y={y}\r\n                                        width={width}\r\n                                        height={height}\r\n                                        stroke=\"black\"\r\n                                        strokeWidth={3}\r\n                                        draggable='true'\r\n                                        fill={fill}\r\n                                        onDragStart={this.handleDragStart}\r\n                                        onDragMove={this.updateLine}\r\n                                        onDragEnd={this.handleDragEnd}\r\n                                        onClick={this.addEdge}\r\n                                        name=\"node\"\r\n                                    />\r\n                                ))}\r\n                                {this.state.canvas.map(({ height, width, x, y, id, fill }, key) => (\r\n                                    <Text\r\n                                        id={\"label\" + id} // label corresponds to node id\r\n                                        x={id > 9 ? x - 9 : x - 4}\r\n                                        y={y - 5}\r\n                                        fontFamily='Lato, sans-serif'\r\n                                        fontStyle=\"bold\"\r\n                                        fontSize={15}\r\n                                        text={id.toString()}\r\n                                        listening={false}\r\n                                    />\r\n                                ))}\r\n                            </Layer>\r\n                            <Layer>\r\n                                <Group draggable={true}>\r\n                                    <Rect\r\n                                        x={window.innerWidth - 299}\r\n                                        y={35}\r\n                                        width={200}\r\n                                        height={100}\r\n                                        fill=\"white\"\r\n                                        shadowBlur={15}\r\n                                        shadowOpacity={.5}\r\n                                        shadowOffsetX={6}\r\n                                        shadowOffsetY={6}\r\n                                        cornerRadius={7}\r\n\r\n                                    />\r\n                                    <Text\r\n                                        x={window.innerWidth - 299}\r\n                                        y={40}\r\n                                        fontFamily='Lato, sans-serif'\r\n                                        fontSize={18}\r\n                                        fontStyle=\"bold\"\r\n                                        text={usefultext}\r\n                                        align='center'\r\n                                        lineHeight={1.3}\r\n                                        width={200}\r\n                                    />\r\n                                </Group>\r\n                            </Layer>\r\n                        </Stage>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}","import logo from './logo.svg';\nimport './App.css';\nimport MainCanvas from './components/canvas.js'\nimport { Stage, Layer, Rect, Text } from 'react-konva';\nimport Konva from 'konva';\nfunction App() {\n  \n  return (\n    <div className=\"App\">\n      <MainCanvas></MainCanvas>\n      \n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}