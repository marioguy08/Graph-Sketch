[{"/Users/leonardbrkanac/Projects/Graph-Sketch/src/index.js":"1","/Users/leonardbrkanac/Projects/Graph-Sketch/src/reportWebVitals.js":"2","/Users/leonardbrkanac/Projects/Graph-Sketch/src/App.js":"3","/Users/leonardbrkanac/Projects/Graph-Sketch/src/components/canvas.js":"4"},{"size":500,"mtime":1614121421872,"results":"5","hashOfConfig":"6"},{"size":362,"mtime":1614121421873,"results":"7","hashOfConfig":"6"},{"size":317,"mtime":1614121421871,"results":"8","hashOfConfig":"6"},{"size":41182,"mtime":1614123106367,"results":"9","hashOfConfig":"6"},{"filePath":"10","messages":"11","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"12"},"9cdjym",{"filePath":"13","messages":"14","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"12"},{"filePath":"15","messages":"16","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"17","usedDeprecatedRules":"12"},{"filePath":"18","messages":"19","errorCount":0,"warningCount":41,"fixableErrorCount":0,"fixableWarningCount":0,"source":"20"},"/Users/leonardbrkanac/Projects/Graph-Sketch/src/index.js",[],["21","22"],"/Users/leonardbrkanac/Projects/Graph-Sketch/src/reportWebVitals.js",[],"/Users/leonardbrkanac/Projects/Graph-Sketch/src/App.js",["23","24","25","26","27","28"],"import logo from './logo.svg';\nimport './App.css';\nimport MainCanvas from './components/canvas.js'\nimport { Stage, Layer, Rect, Text } from 'react-konva';\nimport Konva from 'konva';\nfunction App() {\n  \n  return (\n    <div className=\"App\">\n      <MainCanvas></MainCanvas>\n      \n    </div>\n  );\n}\n\nexport default App;\n","/Users/leonardbrkanac/Projects/Graph-Sketch/src/components/canvas.js",["29","30","31","32","33","34","35","36","37","38","39","40","41","42","43","44","45","46","47","48","49","50","51","52","53","54","55","56","57","58","59","60","61","62","63","64","65","66","67","68","69"],"import React, { Component } from \"react\";\nimport Konva from \"konva\";\nimport { Stage, Layer, Ellipse, Circle, Line, Arrow, Text, Rect, Group } from \"react-konva\";\nimport Heap from 'heap-js';\n\nvar counter = 1;\nvar linecounter = 1;\nvar loopcounter = 1;\nconst minHeap = new Heap();\nconst stageRef = React.createRef();\n\nexport default class MainCanvas extends Component {\n    state = {\n        isBipartite: true,\n        delete: false,\n        color: false,\n        numComponents: 0,\n        undirected: true,\n        canvas: [],\n        lines: [],\n        loops: [],\n        bridgeDict: {},\n        showBridges: false,\n        adjList: {},\n        edgenodestart: [null, null, null],\n    };\n\n    generateNode = (pos) => {\n        var newNode = {};\n        if (minHeap.length > 0) {\n            var newid = minHeap.pop();\n            newNode = {\n                id: newid,\n                x: pos.x,\n                y: pos.y,\n                width: 40,\n                height: 40,\n                fill: \"white\"\n            }\n            counter -= 1;\n        } else {\n            newNode = {\n                id: counter,\n                x: pos.x,\n                y: pos.y,\n                width: 40,\n                height: 40,\n                fill: \"white\"\n            }\n        }\n        return newNode;\n    }\n\n    handleClick = (e) => {\n        if (this.state.delete != true) {\n            const emptySpace = e.target === e.target.getStage();\n            if (!emptySpace) {\n                return;\n            }\n            const pos = e.target.getStage().getPointerPosition();\n            var newnode = this.generateNode(pos);\n            counter += 1\n            this.setState(prevState => ({\n                canvas: [...prevState.canvas, { ...newnode }],\n                edgenodestart: [null, null, null]\n\n            }), () => this.genAdjlist());\n        }\n    };\n\n    handleDragStart = e => {\n        e.target.moveToTop();\n        e.target.to({\n            scaleX: 1.15,\n            scaleY: 1.15,\n        });\n    };\n\n    handleDragEnd = e => {\n        var newnodes = [...this.state.canvas];\n        var nodeid = e.target.attrs.id;\n        for (var i = 0; i < newnodes.length; i += 1) {\n            if (newnodes[i].id === parseInt(nodeid)) {\n                newnodes[i].x = e.target.attrs.x;\n                newnodes[i].y = e.target.attrs.y;\n                break;\n            }\n        }\n        var newloops = [...this.state.loops];\n        for (var i = 0; i < newloops.length; i += 1) {\n            if (newloops[i].nodeid === nodeid) {\n                newloops[i].x = e.target.attrs.x;\n                newloops[i].y = e.target.attrs.y - 40;\n                break;\n            }\n        }\n        this.setState({\n            loops: newloops,\n            canvas: newnodes\n        })\n        e.target.to({\n            duration: 0.5,\n            easing: Konva.Easings.ElasticEaseOut,\n            scaleX: 1,\n            scaleY: 1,\n        });\n    };\n    addEdge = (e) => {\n        if (this.state.color === true && this.state.delete == false) {\n            var newnodes = [...this.state.canvas];\n            for (var i = 0; i < newnodes.length; i += 1) {\n                if ((newnodes[i].id) === parseInt(e.target.attrs.id)) {\n                    if (newnodes[i].fill === \"white\") {\n                        newnodes[i].fill = \"#007bff\"\n                    }\n                    else if (newnodes[i].fill === \"#007bff\") {\n                        newnodes[i].fill = \"#ff5353\"\n                    }\n                    else {\n                        newnodes[i].fill = \"white\"\n                    }\n                    break;\n                }\n            }\n            this.setState({\n                canvas: newnodes,\n                edgenodestart: [null, null, null]\n            })\n            return;\n        }\n        var layer = stageRef.current;\n        if (this.state.delete === true) {\n            var nodedeleteid = e.target.attrs.id;\n            var nodedelete = layer.findOne('#' + e.target.attrs.id);\n            var lines = layer.find('.line');\n            var linedeleteids = {};\n            for (i = 0; i < lines.length; i += 1) {\n                if (lines[i].attrs.startid === nodedelete.attrs.id || lines[i].attrs.endid === nodedelete.attrs.id) {\n                    linedeleteids[lines[i].attrs.id] = true;\n                }\n            }\n            var newlines = [...this.state.lines];\n            for (var i = newlines.length - 1; i > -1; i -= 1) {\n                if ((\"line\" + newlines[i].id) in linedeleteids) {\n                    newlines.splice(i, 1);\n                }\n            }\n            this.setState({\n                lines: newlines\n            })\n            var newnodes = [...this.state.canvas];\n            for (var i = 0; i < newnodes.length; i += 1) {\n                if (parseInt(newnodes[i].id) === parseInt(nodedelete.attrs.id)) {\n                    newnodes.splice(i, 1);\n                    break;\n                }\n            }\n            this.setState({\n                canvas: newnodes\n            })\n            minHeap.push(parseInt(nodedeleteid));\n            var newloops = [...this.state.loops];\n            for (var i = 0; i < newloops.length; i += 1) {\n                if ((newloops[i].nodeid) === nodedeleteid) {\n                    newloops.splice(i, 1);\n                    break;\n                }\n            }\n            this.setState({\n                loops: newloops\n            }, () => this.genAdjlist());\n            this.setState({\n                edgenodestart: [null, null, null]\n            })\n            return;\n        }\n        if (this.state.edgenodestart[0] == null) {\n            this.setState({\n                edgenodestart: [e.target.attrs.id, e.target.attrs.x, e.target.attrs.y]\n            })\n        } else {\n            if (e.target.attrs.id === this.state.edgenodestart[0]) { // create loop\n                var prevloop = layer.findOne('#loop' + e.target.attrs.id); // check if there is already loop\n                if (prevloop === undefined) {\n                    this.setState({\n                        edgenodestart: [null, null, null]\n                    })\n                    var label = layer.findOne('#label' + e.target.attrs.id);\n                    e.target.moveToTop();\n                    label.moveToTop();\n                    var newLoop = {\n                        nodeid: e.target.attrs.id,\n                        id: loopcounter,\n                        x: e.target.attrs.x,\n                        y: e.target.attrs.y - 40,\n                        width: 25,\n                        height: 40\n                    }\n                    loopcounter += 1;\n                    var newloop = this.state.loops.concat(newLoop);\n                    this.setState({ loops: newloop }, () => this.genAdjlist())\n                    this.setState({\n                        edgenodestart: [null, null, null]\n                    })\n                    return\n                }\n                this.setState({\n                    edgenodestart: [null, null, null]\n                })\n                return\n            }\n            var flag = 0;\n            var nodestart = this.state.edgenodestart[0];\n            var nodestartx = this.state.edgenodestart[1];\n            var nodestarty = this.state.edgenodestart[2];\n            var nodeend = e.target.attrs.id;\n            var nodeendx = e.target.attrs.x;\n            var nodeendy = e.target.attrs.y;\n            var lines = layer.find('.line');\n            var numlines = 0;\n            var i = 0\n            for (i = 0; i < lines.length; i += 1) {\n                if ((lines[i].attrs.startid === nodestart && lines[i].attrs.endid === nodeend) || (lines[i].attrs.startid === nodeend && lines[i].attrs.endid === nodestart)) {\n\n                    flag = 1;\n                    numlines += 1;\n                }\n            }\n            const radius = -50;\n            let angle = 0;\n            var flag = 0;\n            if (nodestartx >= nodeendx) {\n                flag = 1;\n            }\n            const dx = nodestartx - nodeendx;\n            const dy = nodestarty - nodeendy;\n            angle = Math.atan2(-dy, dx);\n            if (numlines === 0) {\n                nodestartx = nodestartx + -radius * (Math.cos(angle + Math.PI) * .5);\n                nodestarty = nodestarty + radius * (Math.sin(angle + Math.PI) * .5);\n                nodeendx = nodeendx + -radius * (Math.cos(angle) * .5);\n                nodeendy = nodeendy + radius * (Math.sin(angle) * .5);\n            }\n            else if (numlines === 1) {\n                if (flag != 1) {\n                    nodestartx = nodestartx + -radius * (Math.cos(angle + Math.PI - .5) * .5);\n                    nodestarty = nodestarty + radius * (Math.sin(angle + Math.PI - .5) * .5);\n                    nodeendx = nodeendx + -radius * (Math.cos(angle + .5) * .5);\n                    nodeendy = nodeendy + radius * (Math.sin(angle + .5) * .5);\n                } else {\n                    nodestartx = nodestartx + -radius * (Math.cos(angle + Math.PI + .5) * .5);\n                    nodestarty = nodestarty + radius * (Math.sin(angle + Math.PI + .5) * .5);\n                    nodeendx = nodeendx + -radius * (Math.cos(angle - .5) * .5);\n                    nodeendy = nodeendy + radius * (Math.sin(angle - .5) * .5);\n                }\n            }\n            else if (numlines === 2) {\n\n                if (flag != 1) {\n                    nodestartx = nodestartx + -radius * (Math.cos(angle + Math.PI + .5) * .5);\n                    nodestarty = nodestarty + radius * (Math.sin(angle + Math.PI + .5) * .5);\n                    nodeendx = nodeendx + -radius * (Math.cos(angle - .5) * .5);\n                    nodeendy = nodeendy + radius * (Math.sin(angle - .5) * .5);\n                } else {\n                    nodestartx = nodestartx + -radius * (Math.cos(angle + Math.PI - .5) * .5);\n                    nodestarty = nodestarty + radius * (Math.sin(angle + Math.PI - .5) * .5);\n                    nodeendx = nodeendx + -radius * (Math.cos(angle + .5) * .5);\n                    nodeendy = nodeendy + radius * (Math.sin(angle + .5) * .5);\n                };\n            }\n            else {\n                this.setState({\n                    edgenodestart: [null, null, null]\n                })\n                return;\n            }\n\n            var isgrouped = false;\n            var groupnumber = numlines + 1;\n            if (numlines > 0) {\n                isgrouped = true;\n            }\n            var newline = {\n                id: linecounter,\n                startid: nodestart,\n                endid: nodeend,\n                points: [nodestartx, nodestarty, nodeendx, nodeendy],\n                isgrouped: isgrouped,\n                fill: 'black',\n                groupnumber: groupnumber\n            }\n            this.setState(prevState => ({\n                lines: [...prevState.lines, { ...newline }]\n            }), () => this.genAdjlist());\n            this.setState({\n                edgenodestart: [null, null, null]\n            })\n            linecounter += 1;\n\n        }\n\n    }\n\n    updateLine = (e) => {\n        var nodeid = e.target.attrs.id;\n        var layer = stageRef.current;\n        //UPDATE ALL LINES\n        var lines = layer.find('.line');\n        for (var i = 0; i < lines.length; i += 1) {\n            if (lines[i].attrs.startid === nodeid) {\n                var nodestart = layer.findOne('#' + lines[i].attrs.startid);\n                var nodeend = layer.findOne('#' + lines[i].attrs.endid);\n                var flag = 0;\n                var nodestartx = nodestart.attrs.x;\n                var nodestarty = nodestart.attrs.y;\n                var nodeendx = nodeend.attrs.x;\n                var nodeendy = nodeend.attrs.y;\n                if (nodestartx >= nodeendx) {\n                    flag = 1;\n                }\n                const radius = -50;\n                const dx = nodestartx - nodeendx;\n                const dy = nodestarty - nodeendy;\n                let angle = Math.atan2(-dy, dx);\n                if (lines[i].attrs.groupnumber === 1 || lines[i].attrs.isgrouped === false) {\n                    var curpoints = lines[i].attrs.points\n                    nodestartx = e.target.attrs.x + -radius * (Math.cos(angle + Math.PI) * .5);\n                    nodestarty = e.target.attrs.y + radius * (Math.sin(angle + Math.PI) * .5);\n                    nodeendx = nodeendx + -radius * (Math.cos(angle) * .5);\n                    nodeendy = nodeendy + radius * (Math.sin(angle) * .5);\n                    curpoints[0] = nodestartx;\n                    curpoints[1] = nodestarty;\n                    curpoints[2] = nodeendx;\n                    curpoints[3] = nodeendy;\n                    lines[i].attrs.points = curpoints;\n                }\n                else if (lines[i].attrs.groupnumber === 2) {\n                    if (flag != 1) {\n                        nodestartx = nodestartx + -radius * (Math.cos(angle + Math.PI - .5) * .5);\n                        nodestarty = nodestarty + radius * (Math.sin(angle + Math.PI - .5) * .5);\n                        nodeendx = nodeendx + -radius * (Math.cos(angle + .5) * .5);\n                        nodeendy = nodeendy + radius * (Math.sin(angle + .5) * .5);\n                    } else {\n                        nodestartx = nodestartx + -radius * (Math.cos(angle + Math.PI + .5) * .5);\n                        nodestarty = nodestarty + radius * (Math.sin(angle + Math.PI + .5) * .5);\n                        nodeendx = nodeendx + -radius * (Math.cos(angle - .5) * .5);\n                        nodeendy = nodeendy + radius * (Math.sin(angle - .5) * .5);\n                    }\n\n                    var curpoints = lines[i].attrs.points\n                    curpoints[0] = nodestartx;\n                    curpoints[1] = nodestarty;\n                    curpoints[2] = nodeendx;\n                    curpoints[3] = nodeendy;\n                    lines[i].attrs.points = curpoints;\n                }\n                else if (lines[i].attrs.groupnumber === 3) {\n                    if (flag != 1) {\n                        nodestartx = nodestartx + -radius * (Math.cos(angle + Math.PI + .5) * .5);\n                        nodestarty = nodestarty + radius * (Math.sin(angle + Math.PI + .5) * .5);\n                        nodeendx = nodeendx + -radius * (Math.cos(angle - .5) * .5);\n                        nodeendy = nodeendy + radius * (Math.sin(angle - .5) * .5);\n                    } else {\n                        nodestartx = nodestartx + -radius * (Math.cos(angle + Math.PI - .5) * .5);\n                        nodestarty = nodestarty + radius * (Math.sin(angle + Math.PI - .5) * .5);\n                        nodeendx = nodeendx + -radius * (Math.cos(angle + .5) * .5);\n                        nodeendy = nodeendy + radius * (Math.sin(angle + .5) * .5);\n                    }\n\n                    var curpoints = lines[i].attrs.points\n                    curpoints[0] = nodestartx;\n                    curpoints[1] = nodestarty;\n                    curpoints[2] = nodeendx;\n                    curpoints[3] = nodeendy;\n                    lines[i].attrs.points = curpoints;\n                }\n            }\n            if (lines[i].attrs.endid === nodeid) {\n                var nodestart = layer.findOne('#' + lines[i].attrs.startid);\n                var nodeend = layer.findOne('#' + lines[i].attrs.endid);\n                var nodestartx = nodestart.attrs.x;\n                var nodestarty = nodestart.attrs.y;\n                var nodeendx = nodeend.attrs.x;\n                var nodeendy = nodeend.attrs.y;\n                const radius = -50;\n                var flag = 0;\n                var nodestartx = nodestart.attrs.x;\n                var nodestarty = nodestart.attrs.y;\n                var nodeendx = nodeend.attrs.x;\n                var nodeendy = nodeend.attrs.y;\n                if (nodestartx >= nodeendx) {\n                    flag = 1;\n                }\n                const dx = nodestartx - nodeendx;\n                const dy = nodestarty - nodeendy;\n                let angle = Math.atan2(-dy, dx);\n\n                if (lines[i].attrs.groupnumber === 1 || lines[i].attrs.isgrouped === false) {\n                    var curpoints = lines[i].attrs.points\n                    nodestartx = nodestartx + -radius * (Math.cos(angle + Math.PI) * .5);\n                    nodestarty = nodestarty + radius * (Math.sin(angle + Math.PI) * .5);\n                    nodeendx = nodeendx + -radius * (Math.cos(angle) * .5);\n                    nodeendy = nodeendy + radius * (Math.sin(angle) * .5);\n\n                    curpoints[2] = nodeendx;\n                    curpoints[3] = nodeendy;\n                    curpoints[0] = nodestartx;\n                    curpoints[1] = nodestarty;\n                    lines[i].attrs.points = curpoints;\n                }\n                else if (lines[i].attrs.groupnumber === 2) {\n                    if (flag != 1) {\n                        nodestartx = nodestartx + -radius * (Math.cos(angle + Math.PI - .5) * .5);\n                        nodestarty = nodestarty + radius * (Math.sin(angle + Math.PI - .5) * .5);\n                        nodeendx = nodeendx + -radius * (Math.cos(angle + .5) * .5);\n                        nodeendy = nodeendy + radius * (Math.sin(angle + .5) * .5);\n                    } else {\n                        nodestartx = nodestartx + -radius * (Math.cos(angle + Math.PI + .5) * .5);\n                        nodestarty = nodestarty + radius * (Math.sin(angle + Math.PI + .5) * .5);\n                        nodeendx = nodeendx + -radius * (Math.cos(angle - .5) * .5);\n                        nodeendy = nodeendy + radius * (Math.sin(angle - .5) * .5);\n                    }\n                    var curpoints = lines[i].attrs.points\n                    curpoints[0] = nodestartx;\n                    curpoints[1] = nodestarty;\n                    curpoints[2] = nodeendx;\n                    curpoints[3] = nodeendy;\n                    lines[i].attrs.points = curpoints;\n                }\n                else if (lines[i].attrs.groupnumber === 3) {\n                    if (flag != 1) {\n                        nodestartx = nodestartx + -radius * (Math.cos(angle + Math.PI + .5) * .5);\n                        nodestarty = nodestarty + radius * (Math.sin(angle + Math.PI + .5) * .5);\n                        nodeendx = nodeendx + -radius * (Math.cos(angle - .5) * .5);\n                        nodeendy = nodeendy + radius * (Math.sin(angle - .5) * .5);\n                    } else {\n                        nodestartx = nodestartx + -radius * (Math.cos(angle + Math.PI - .5) * .5);\n                        nodestarty = nodestarty + radius * (Math.sin(angle + Math.PI - .5) * .5);\n                        nodeendx = nodeendx + -radius * (Math.cos(angle + .5) * .5);\n                        nodeendy = nodeendy + radius * (Math.sin(angle + .5) * .5);\n                    }\n\n                    var curpoints = lines[i].attrs.points\n                    curpoints[0] = nodestartx;\n                    curpoints[1] = nodestarty;\n                    curpoints[2] = nodeendx;\n                    curpoints[3] = nodeendy;\n                    lines[i].attrs.points = curpoints;\n                }\n\n            }\n\n        }\n        // update position of loops and labels\n        var editnode = layer.findOne('#' + nodeid);\n        var loop = layer.findOne('#loop' + nodeid);\n        if (loop) {\n            loop.position({ x: editnode.attrs.x, y: editnode.attrs.y - 40 })\n        }\n        var label = layer.findOne('#label' + nodeid);\n        if (label) {\n            label.moveToTop();\n            label.position({ x: nodeid > 9 ? editnode.attrs.x - 9 : editnode.attrs.x - 4, y: editnode.attrs.y - 5 });\n        }\n    }\n\n    genAdjlist = (returnundirected) => {\n        var layer = stageRef.current;\n        var lines = layer.find('.line');\n        var adjList = {};\n        for (var i = 0; i < this.state.canvas.length; i += 1) {\n            adjList[this.state.canvas[i].id] = [];\n        }\n        for (var i = 0; i < this.state.loops.length; i += 1) {\n            var selfid = this.state.loops[i].nodeid;\n            adjList[selfid].push(selfid);\n        }\n        for (var i = 0; i < lines.length; i += 1) {\n            var startend = [lines[i].attrs.startid, lines[i].attrs.endid];\n            adjList[startend[0]].push(parseInt(startend[1]));\n            if (this.state.undirected === true || returnundirected === true) {\n                adjList[startend[1]].push(parseInt(startend[0]));\n            }\n        }\n        if (!returnundirected) {\n            this.setState({ adjList: adjList }, () => {\n                this.isBipartite();\n                this.numComponents();\n                this.findBridges();\n            }\n            );\n        }\n        if (returnundirected === true) {\n            return adjList;\n        }\n    }\n\n    numComponents = () => {\n        var numComponents = 0;\n        var visited = {};\n        var queue = [];\n        for (const adjDict in this.state.adjList) {\n            if (adjDict in visited === false) {\n                numComponents += 1;\n                queue.push(adjDict);\n                visited[adjDict] = true;\n                while (queue.length > 0) {\n                    var curnode = queue.shift();\n                    for (var i = 0; i < this.state.adjList[curnode].length; i += 1) {\n                        if (this.state.adjList[curnode][i] in visited === false) {\n                            queue.push(this.state.adjList[curnode][i]);\n                            visited[this.state.adjList[curnode][i]] = true;\n                        }\n                    }\n                }\n            }\n        }\n        this.setState({\n            numComponents: numComponents\n        })\n    }\n\n    topologicalSort = () => {\n        var processed = {};\n        var visiting = {};\n        var stack = [];\n        for (var node in this.state.adjList) {\n            if (node in processed != true) {\n\n                if (dfs(node, visiting, processed, stack, this.state.adjList)) {\n                    return [];\n                }\n            }\n        }\n        stack.reverse()\n        return stack;\n        function dfs(node, cyclecheck, processed, output, adjList) {\n            if (node in processed) {\n                return false;\n            }\n            if (node in cyclecheck) {\n                return true; // we want to bubble up true in case there is cycle in directed graph.\n            }\n            cyclecheck[node] = true;\n            for (var i = 0; i < adjList[node].length; i += 1) {\n                var foundcycle = dfs(adjList[node][i], cyclecheck, processed, output, adjList);\n                if (foundcycle) {\n                    return true;\n                }\n            }\n            delete cyclecheck[node];\n            processed[node] = true;\n            output.push(\",\");\n            output.push(parseInt(node));\n            return false\n        }\n    }\n\n    isBipartite = () => {\n        var isBipartite = true;\n        if (this.state.lines.length === 0 && this.state.loops.length === 0) {\n            //dont do anything if there arent any edges\n        } else {\n            if (this.state.undirected === false) { // we always want to treat the graph as undirected when checking if it is bipartite\n                var adjList = this.genAdjlist(true);\n            } else {\n                var adjList = this.state.adjList;\n            }\n            let colors = {}; // will store the color of each node with false and true\n            for (var adjDict in this.state.adjList) {\n                if (adjDict in colors === false) {// only do bfs on nodes that werent visited\n                    var queue = [] // queue for breadth first search\n                    queue.push([adjDict, false, -1]);\n                    colors[adjDict] = false; // mark visited\n                    while (queue.length > 0) {\n                        var curnode = queue.shift();// pop first node by shifting array\n                        for (var i = 0; i < adjList[curnode[0]].length; i += 1) {\n                            if (adjList[curnode[0]][i] === curnode[2]) {\n                                // we dont want to go back to the neighbor we previosly visited\n                                continue;\n                            }\n                            if (adjList[curnode[0]][i] in colors === true && colors[adjList[curnode[0]][i]] != curnode[1]) {\n                                // in case we reach node that is visited but is the opposite color then we also know the rest of its neighbors and so on are bipartite\n                                continue;\n                            }\n                            if (adjList[curnode[0]][i] in colors === true && colors[adjList[curnode[0]][i]] === curnode[1]) {\n                                // in case we reach a visited node that wasnt started on and its color is the same as the current color then not bipartite\n                                isBipartite = false;\n                                break;\n                            }\n                            // push neighbor to queue\n                            colors[adjList[curnode[0]][i]] = !curnode[1]; // mark visited\n                            queue.push([adjList[curnode[0]][i], !curnode[1], curnode[0]]);\n                        }\n                    }\n                }\n            }\n        }\n        this.setState({\n            isBipartite: isBipartite\n        });\n    }\n\n    findBridges = () => {\n        var bridgeDict = {};\n        if (this.state.undirected === true && this.state.showBridges === true) {\n            var initTime = {};\n            var lowestAncestor = {};\n            var timer = 1;\n            for (var node in this.state.adjList) {\n                if (node in initTime === false) {\n                    // do dfs if not visited\n                    dfs(parseInt(node), -1, initTime, lowestAncestor, timer, this.state.adjList);\n                }\n            }\n        }\n        this.setState({\n            bridgeDict: bridgeDict\n        }, () => this.showBridges());\n        function dfs(node, parent, initTime, lowestAncestor, timer, adjList) {\n            initTime[node] = timer;\n            lowestAncestor[node] = timer;\n            timer += 1\n            if (adjList[node] != []) {\n                for (var child = 0; child < adjList[node].length; child += 1) {\n                    if (adjList[node][child] === parent) { // dont go back to parent\n                        continue;\n                    }\n                    else if (adjList[node][child] in initTime) {// found visited node so update low of curnode if it is \n                        lowestAncestor[node] = Math.min(initTime[adjList[node][child]], lowestAncestor[node])\n                    } else {// child not visited\n                        dfs(adjList[node][child], node, initTime, lowestAncestor, timer, adjList);\n                        if (lowestAncestor[adjList[node][child]] > initTime[node]) {// if only way to child is from parent then it is bridge\n                            //checks for parallel edges since it wont be a bridge if there is another edge\n                            var counter = 0;\n                            for (var j = 0; j < adjList[node].length; j += 1) {\n                                if (adjList[node][j] === adjList[node][child]) {\n                                    counter += 1;\n                                }\n                            }\n                            if (counter < 2) { // if no other edge going from node to child other than one, then its a bridge.\n                                bridgeDict[[node, adjList[node][child]]] = true;\n                            }\n                        } else { // otherwise update the lowest ancestor reachable from current node ny seeing if the childs lowest acnestor is lower\n                            lowestAncestor[node] = Math.min(lowestAncestor[node], lowestAncestor[adjList[node][child]]);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    deleteLine = (e) => {\n        var newlines = [...this.state.lines];\n        for (var i = 0; i < newlines.length; i += 1) {\n            if (\"line\" + newlines[i].id === e.target.attrs.id) {\n                newlines.splice(i, 1);\n                break;\n            }\n        }\n        this.setState({\n            lines: newlines\n        }, () => this.genAdjlist());\n    }\n\n    deleteLoop = (e) => {\n        var newloops = [...this.state.loops];\n        for (var i = 0; i < newloops.length; i += 1) {\n            if ((\"loop\" + newloops[i].nodeid) === e.target.attrs.id) {\n                newloops.splice(i, 1);\n                break;\n            }\n        }\n        this.setState({\n            loops: newloops\n        }, () => this.genAdjlist())\n    }\n\n    changeUndirected = (val) => {\n        if (val) {\n            this.setState((prevState) => ({ undirected: true }), () => this.genAdjlist());\n        } else {\n            this.setState((prevState) => ({ undirected: false }), () => this.genAdjlist());\n        }\n\n    }\n\n    createntries = () => {\n        var JSXadjList = [];\n        JSXadjList.push(<li className=\"listitems\" key={node} style={{ margin: \"13px\", minWidth: \"110px\" }}>Adjacency List:</li>);\n        for (var node in this.state.adjList) {\n            var neighborlist = [];\n            for (var i = 0; i < this.state.adjList[node].length; i += 1) {\n                neighborlist.push(this.state.adjList[node][i]);\n            }\n            neighborlist = neighborlist.toString();\n            JSXadjList.push(<li className=\"listitems\" key={node} style={{ margin: \"13px\", minWidth: \"110px\", letterSpacing: \"2px\" }}>{node}:{neighborlist}</li>);\n        }\n        return JSXadjList;\n    }\n\n    showBridges = () => {\n        var lines = this.state.lines;\n        for (var i = 0; i < lines.length; i += 1) {\n            if (this.state.undirected === true) {\n                var key = lines[i].startid.toString() + \",\" + lines[i].endid.toString();\n                var keyrev = lines[i].endid.toString() + \",\" + lines[i].startid.toString();\n                if (key in this.state.bridgeDict || keyrev in this.state.bridgeDict) {\n                    lines[i].fill = 'red';\n                } else {\n                    lines[i].fill = 'black';\n                }\n            } else {\n                lines[i].fill = 'black';\n            }\n        }\n        this.setState({\n            lines: lines\n        })\n    }\n\n    render() {\n        var topologicalordering = this.topologicalSort();\n        topologicalordering.slice(-1)\n        if (topologicalordering.length < 1 && this.state.canvas.length > 0) {\n            topologicalordering = \"Cycle Detected!\"\n        }\n        var JSXadjList = this.createntries();\n        var usefultext = (this.state.isBipartite ? \"Bipartite: True\\n\" : \"Bipartite: False\\n\") +\n            (\"Components: \" + (this.state.undirected ? this.state.numComponents : \"N/A\") + \"\\n\") +\n            (\"V: \" + (this.state.canvas.length) + \"\\n\") +\n            (\"E: \" + (this.state.lines.length + this.state.loops.length));\n        return (\n            <div>\n                <div style={{ display: \"flex\", flexDirection: \"row\", boxShadow: \"rgba(0, 0, 0, 0.15) 1.95px 1.95px 2.6px\", justifyContent: \"space-between\" }}>\n                    <h1 className=\"titletext\">Graph Sketcher</h1>\n                    <div style={{ display: \"flex\", flexDirection: \"row\", marginRight: \"5rem\" }}>\n                        {\n                            this.state.undirected === true ?\n                                <p className='checktext'>Show Bridges <input type=\"checkbox\" readOnly={true} className='checkbox' checked={this.state.showBridges === true ? true : false} onClick={() => this.setState((prevState) => ({ showBridges: !prevState.showBridges }), () => this.genAdjlist())}></input></p>\n                                :\n                                null\n                        }\n                        <div style={{ display: \"flex\", flexDirection: \"row\" }}>\n                            <button className=\"optionsbuttons left\" style={this.state.delete === false && this.state.color == false ? { backgroundColor: \"#272942\" } : { backgroundColor: \"#4a508b\" }} onClick={() => this.setState({ delete: false, color: false })}>DRAW</button>\n                            <button className=\"optionsbuttons\" style={this.state.delete === true ? { backgroundColor: \"#272942\" } : { backgroundColor: \"#4a508b\" }} onClick={() => this.setState({ delete: true, color: false })}>DELETE</button>\n                            <button className=\"optionsbuttons right\" style={this.state.delete === false && this.state.color == true ? { backgroundColor: \"#272942\" } : { backgroundColor: \"#4a508b\" }} onClick={() => this.setState({ color: true, delete: false })}>COLOR</button>\n                        </div>\n                        &nbsp;\n                        <div style={{ display: \"flex\", flexDirection: \"row\" }}>\n                            <button className=\"optionsbuttons left\" style={this.state.undirected ? { backgroundColor: \"#272942\" } : { backgroundColor: \"#4a508b\" }} onClick={() => this.changeUndirected(true)}>UNDIRECTED</button>\n                            <button className=\"optionsbuttons right\" style={this.state.undirected ? { backgroundColor: \"#4a508b\" } : { backgroundColor: \"#272942\" }} onClick={() => this.changeUndirected(false)}>DIRECTED</button>\n                        </div>\n                    </div>\n                </div>\n                <div >\n                    <div style={{ display: \"flex\", flexDirection: \"row\" }}>\n                        <div style={{ display: \"flex\", flexDirection: \"row\" }}>\n                            <ul className=\"adjListContainer\" style={{ height: \"100%\", padding: \"0px\", margin: \"0px\", textAlign: \"left\", boxShadow: \"rgba(0, 0, 0, 0.15) 1.95px 1.95px 2.6px\", listStyleType: \"none\" }}>\n                                {JSXadjList}\n                            </ul>\n                            {\n                                this.state.undirected === false ?\n                                    <p className=\"topo\" style={{ boxShadow: \"rgba(0, 0, 0, 0.15) 1.95px 1.95px 2.6px\" }}>Topological Ordering: {topologicalordering}</p>\n                                    :\n                                    null\n                            }\n                        </div>\n                        <Stage width={window.innerWidth - 20} height={window.innerHeight + 400} onClick={this.handleClick} ref={stageRef} style={{ left: 0, position: \"absolute\" }}  >\n                            <Layer>\n                                {this.state.loops.map(({ id, x, y, width, height, nodeid }, key) => ( // like a \"for loop\", this maps over this.state.canvas objects and pulls out the height, width, x, y properties to be used below\n                                    // loop edges will be circles rotated around offset\n                                    <Ellipse\n                                        id={\"loop\" + nodeid}\n                                        nodeid={nodeid}\n                                        key={key}\n                                        x={x}\n                                        y={y}\n                                        radiusX={width}\n                                        radiusY={height}\n                                        stroke='black'\n                                        strokeWidth={3}\n                                        onClick={this.deleteLoop}\n                                    />\n                                ))}\n                                {this.state.lines.map(({ points, startid, endid, isgrouped, groupnumber, id, fill }, key) => ( // like a \"for loop\", this maps over this.state.canvas objects and pulls out the height, width, x, y properties to be used below\n                                    this.state.undirected ?\n                                        <Line\n                                            id={\"line\" + id}\n                                            key={key}\n                                            startid={startid}\n                                            endid={endid}\n                                            points={points}\n                                            stroke={fill}\n                                            strokeWidth={4}\n                                            isgrouped={isgrouped}\n                                            groupnumber={groupnumber}\n                                            name=\"line\"\n                                            onClick={this.deleteLine}\n                                        />\n                                        :\n                                        <Arrow\n                                            id={\"line\" + id}\n                                            key={key}\n                                            startid={startid}\n                                            endid={endid}\n                                            points={points}\n                                            stroke={fill}\n                                            strokeWidth={4}\n                                            isgrouped={isgrouped}\n                                            groupnumber={groupnumber}\n                                            name=\"line\"\n                                            pointerWidth={7}\n                                            fill=\"black\"\n                                            onClick={this.deleteLine}\n                                        />\n                                ))}\n                                {this.state.canvas.map(({ height, width, x, y, id, fill }, key) => (\n                                    // loop edges will be circles rotated around offset\n                                    <Circle\n                                        id={id.toString()}\n                                        key={key}\n                                        x={x}\n                                        y={y}\n                                        width={width}\n                                        height={height}\n                                        stroke=\"black\"\n                                        strokeWidth={3}\n                                        draggable='true'\n                                        fill={fill}\n                                        onDragStart={this.handleDragStart}\n                                        onDragMove={this.updateLine}\n                                        onDragEnd={this.handleDragEnd}\n                                        onClick={this.addEdge}\n                                        name=\"node\"\n                                    />\n                                ))}\n                                {this.state.canvas.map(({ height, width, x, y, id, fill }, key) => (\n                                    <Text\n                                        id={\"label\" + id} // label corresponds to node id\n                                        x={id > 9 ? x - 9 : x - 4}\n                                        y={y - 5}\n                                        fontFamily='Lato, sans-serif'\n                                        fontStyle=\"bold\"\n                                        fontSize={15}\n                                        text={id.toString()}\n                                        listening={false}\n                                    />\n                                ))}\n                            </Layer>\n                            <Layer>\n                                <Group draggable={true}>\n                                    <Rect\n                                        x={window.innerWidth - 299}\n                                        y={35}\n                                        width={200}\n                                        height={100}\n                                        fill=\"white\"\n                                        shadowBlur={15}\n                                        shadowOpacity={.5}\n                                        shadowOffsetX={6}\n                                        shadowOffsetY={6}\n                                        cornerRadius={7}\n\n                                    />\n                                    <Text\n                                        x={window.innerWidth - 299}\n                                        y={40}\n                                        fontFamily='Lato, sans-serif'\n                                        fontSize={18}\n                                        fontStyle=\"bold\"\n                                        text={usefultext}\n                                        align='center'\n                                        lineHeight={1.3}\n                                        width={200}\n                                    />\n                                </Group>\n                            </Layer>\n                        </Stage>\n                    </div>\n                </div>\n            </div>\n        );\n    }\n}",{"ruleId":"70","replacedBy":"71"},{"ruleId":"72","replacedBy":"73"},{"ruleId":"74","severity":1,"message":"75","line":1,"column":8,"nodeType":"76","messageId":"77","endLine":1,"endColumn":12},{"ruleId":"74","severity":1,"message":"78","line":4,"column":10,"nodeType":"76","messageId":"77","endLine":4,"endColumn":15},{"ruleId":"74","severity":1,"message":"79","line":4,"column":17,"nodeType":"76","messageId":"77","endLine":4,"endColumn":22},{"ruleId":"74","severity":1,"message":"80","line":4,"column":24,"nodeType":"76","messageId":"77","endLine":4,"endColumn":28},{"ruleId":"74","severity":1,"message":"81","line":4,"column":30,"nodeType":"76","messageId":"77","endLine":4,"endColumn":34},{"ruleId":"74","severity":1,"message":"82","line":5,"column":8,"nodeType":"76","messageId":"77","endLine":5,"endColumn":13},{"ruleId":"83","severity":1,"message":"84","line":55,"column":31,"nodeType":"85","messageId":"86","endLine":55,"endColumn":33},{"ruleId":"87","severity":1,"message":"88","line":90,"column":18,"nodeType":"76","messageId":"89","endLine":90,"endColumn":19},{"ruleId":"83","severity":1,"message":"90","line":109,"column":60,"nodeType":"85","messageId":"86","endLine":109,"endColumn":62},{"ruleId":"87","severity":1,"message":"88","line":143,"column":22,"nodeType":"76","messageId":"89","endLine":143,"endColumn":23},{"ruleId":"87","severity":1,"message":"91","line":151,"column":17,"nodeType":"76","messageId":"89","endLine":151,"endColumn":25},{"ruleId":"87","severity":1,"message":"88","line":152,"column":22,"nodeType":"76","messageId":"89","endLine":152,"endColumn":23},{"ruleId":"87","severity":1,"message":"88","line":163,"column":22,"nodeType":"76","messageId":"89","endLine":163,"endColumn":23},{"ruleId":"87","severity":1,"message":"92","line":219,"column":17,"nodeType":"76","messageId":"89","endLine":219,"endColumn":22},{"ruleId":"87","severity":1,"message":"88","line":221,"column":17,"nodeType":"76","messageId":"89","endLine":221,"endColumn":18},{"ruleId":"87","severity":1,"message":"93","line":231,"column":17,"nodeType":"76","messageId":"89","endLine":231,"endColumn":21},{"ruleId":"83","severity":1,"message":"84","line":245,"column":26,"nodeType":"85","messageId":"86","endLine":245,"endColumn":28},{"ruleId":"83","severity":1,"message":"84","line":259,"column":26,"nodeType":"85","messageId":"86","endLine":259,"endColumn":28},{"ruleId":"83","severity":1,"message":"84","line":338,"column":30,"nodeType":"85","messageId":"86","endLine":338,"endColumn":32},{"ruleId":"87","severity":1,"message":"94","line":350,"column":25,"nodeType":"76","messageId":"89","endLine":350,"endColumn":34},{"ruleId":"83","severity":1,"message":"84","line":358,"column":30,"nodeType":"85","messageId":"86","endLine":358,"endColumn":32},{"ruleId":"87","severity":1,"message":"94","line":370,"column":25,"nodeType":"76","messageId":"89","endLine":370,"endColumn":34},{"ruleId":"87","severity":1,"message":"95","line":379,"column":21,"nodeType":"76","messageId":"89","endLine":379,"endColumn":30},{"ruleId":"87","severity":1,"message":"96","line":380,"column":21,"nodeType":"76","messageId":"89","endLine":380,"endColumn":28},{"ruleId":"87","severity":1,"message":"97","line":381,"column":21,"nodeType":"76","messageId":"89","endLine":381,"endColumn":31},{"ruleId":"87","severity":1,"message":"98","line":382,"column":21,"nodeType":"76","messageId":"89","endLine":382,"endColumn":31},{"ruleId":"87","severity":1,"message":"99","line":383,"column":21,"nodeType":"76","messageId":"89","endLine":383,"endColumn":29},{"ruleId":"87","severity":1,"message":"100","line":384,"column":21,"nodeType":"76","messageId":"89","endLine":384,"endColumn":29},{"ruleId":"87","severity":1,"message":"93","line":386,"column":21,"nodeType":"76","messageId":"89","endLine":386,"endColumn":25},{"ruleId":"87","severity":1,"message":"97","line":387,"column":21,"nodeType":"76","messageId":"89","endLine":387,"endColumn":31},{"ruleId":"87","severity":1,"message":"98","line":388,"column":21,"nodeType":"76","messageId":"89","endLine":388,"endColumn":31},{"ruleId":"87","severity":1,"message":"99","line":389,"column":21,"nodeType":"76","messageId":"89","endLine":389,"endColumn":29},{"ruleId":"87","severity":1,"message":"100","line":390,"column":21,"nodeType":"76","messageId":"89","endLine":390,"endColumn":29},{"ruleId":"87","severity":1,"message":"94","line":399,"column":25,"nodeType":"76","messageId":"89","endLine":399,"endColumn":34},{"ruleId":"83","severity":1,"message":"84","line":412,"column":30,"nodeType":"85","messageId":"86","endLine":412,"endColumn":32},{"ruleId":"87","severity":1,"message":"94","line":423,"column":25,"nodeType":"76","messageId":"89","endLine":423,"endColumn":34},{"ruleId":"83","severity":1,"message":"84","line":431,"column":30,"nodeType":"85","messageId":"86","endLine":431,"endColumn":32},{"ruleId":"87","severity":1,"message":"94","line":443,"column":25,"nodeType":"76","messageId":"89","endLine":443,"endColumn":34},{"ruleId":"87","severity":1,"message":"88","line":474,"column":18,"nodeType":"76","messageId":"89","endLine":474,"endColumn":19},{"ruleId":"87","severity":1,"message":"88","line":478,"column":18,"nodeType":"76","messageId":"89","endLine":478,"endColumn":19},{"ruleId":"83","severity":1,"message":"84","line":528,"column":35,"nodeType":"85","messageId":"86","endLine":528,"endColumn":37},{"ruleId":"87","severity":1,"message":"101","line":567,"column":21,"nodeType":"76","messageId":"89","endLine":567,"endColumn":28},{"ruleId":"83","severity":1,"message":"84","line":582,"column":109,"nodeType":"85","messageId":"86","endLine":582,"endColumn":111},{"ruleId":"83","severity":1,"message":"84","line":624,"column":31,"nodeType":"85","messageId":"86","endLine":624,"endColumn":33},{"ruleId":"102","severity":1,"message":"103","line":690,"column":56,"nodeType":"76","messageId":"104","endLine":690,"endColumn":60},{"ruleId":"83","severity":1,"message":"90","line":745,"column":124,"nodeType":"85","messageId":"86","endLine":745,"endColumn":126},{"ruleId":"83","severity":1,"message":"90","line":747,"column":125,"nodeType":"85","messageId":"86","endLine":747,"endColumn":127},"no-native-reassign",["105"],"no-negated-in-lhs",["106"],"no-unused-vars","'logo' is defined but never used.","Identifier","unusedVar","'Stage' is defined but never used.","'Layer' is defined but never used.","'Rect' is defined but never used.","'Text' is defined but never used.","'Konva' is defined but never used.","eqeqeq","Expected '!==' and instead saw '!='.","BinaryExpression","unexpected","no-redeclare","'i' is already defined.","redeclared","Expected '===' and instead saw '=='.","'newnodes' is already defined.","'lines' is already defined.","'flag' is already defined.","'curpoints' is already defined.","'nodestart' is already defined.","'nodeend' is already defined.","'nodestartx' is already defined.","'nodestarty' is already defined.","'nodeendx' is already defined.","'nodeendy' is already defined.","'adjList' is already defined.","no-use-before-define","'node' was used before it was defined.","usedBeforeDefined","no-global-assign","no-unsafe-negation"]